<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Js语言精粹(2)-对象、函数]]></title>
    <url>%2F2017%2F08%2F20%2FJs%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(2)-%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[对象Javascript的简单数据类型包括数字、字符串、布尔值、null值和undefined值。其他所有的值皆是对象，包括数组、函数和正则表达式。 Javascript中的对象是可变的键控集合。对象是属性的容器，其中属性由键值对构成。 Javascript包含一种原型链的特性，允许对象继承另一个对象。正确的使用它能减少对象初始化时消耗的时间和内存。 ES6中新加入了Class。但这个Class只是简洁Javascript面向对象语法的解决方案。详情见深入浅出ES6（十三）：类 Class 对象字面量一个对象字面量就是包围在一对花括号中的零或多个键值对。对象还是可嵌套的。123456789var flight = &#123; airline_name: "Oceanic", "airline-number": 815, departure: &#123; IATA: "SYD", time: "2017-08-20 13:27", city: "HangZhou" &#125;&#125; 检索属性有两种方式，. 表示法，或object[attr]数组访问法，各有用途。 .表示法用于当要检索的属性为不变常量时，可读性更好，强烈推荐用。 数组访问法在属性为字符串变量时，必用（此时点表示法失效）。 12stooge["first-name"]flight.departure.IATA 引用引用传值都是浅复制。 当你需要某个对象的一份拷贝时，一定要用深复制。 12//对于 JSON 安全的对象(只有由对象和数组组成的对象)，我们的深复制非常简单var newObj = JSON.parse(JSON.stringify(obj)); 当你需要共享某一个对象时，即需要多个变量对同一个对象进行操作，一定要用浅复制 1234_.clone = function(obj) &#123; if (_.isObject(obj)) return obj; return _.isArray(obj) ? obj.slice : _.extend(&#123;&#125;,obj);&#125;; 反射反射用于描述能够检查同一系统（或其自身）中的其他代码的代码。 简单点说。在你不知道一个对象内部结构的情况下(你甚至连这个对象的一个属性，或api都不知道)，怎么跟他通信呢？这个时候就要通过一种机制，得到它的内部结构。这种机制就叫做反射。说白了，窥探对象内部结构的方法就叫做反射。 typeof和hasOwnProperty都是很好的例子。 枚举for infor in 的迭代无序，且包括原型链。虽然可以通过hasOwnProperty()和typeof来过滤. 删除1delete another.name; 函数函数包含一组语句，是js 的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于制定对象的行为。 函数对象除了一般函数，其他所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身. Function构造器产生函数对象，会运行类似这样的代码：123this.prototype = &#123; constructor: this&#125;; Function.prototype的proto指向 Object.prototype, Object.prototype.proto === null .prototype是一个对象的原型对象,而proto则是对原型对象的引用。 Object实际上是一个函数，所以可以Object()。 函数的与众不同之处在于他们可以被调用。 函数字面量123var add = function (a,b) &#123; return x + y ;&#125;; 通过函数字面量创建的函数对象包含一个连到外部上下文连接。这被称为闭包. 调用this的值取决于调用的模式，因为this是延迟绑定的。this到对象的绑定发生在调用时。 方法调用模式this绑定调用方法的对象。1234567var myObject = &#123; value: 0, increment: function (inc) &#123; return this.value += typeof inc === 'number' ? inc : 1; &#125;&#125;;myObject.increment(1); 函数调用模式当一个函数不是对象的属性时，他就是被当作函数来调用。此时this绑定到全局对象.1var sum = add(3,4); 这样直接导致的后果是add方法不能利用内部函数来帮助它工作。因为内部函数的this被绑定了错误的值，所以add不能访问对象的属性。 好在可以通过给add方法传入赋值了this的变量，来解决。 解决办法：12345678910myObject.double = function () &#123; var that = this; var helper = function () &#123; that.value = add(that.value,that.value); &#125;; helper();&#125;myObject.double();document.writeln(myObject.value); 构造器调用模式javascript对原型继承不自信的表现。 如果在一个函数前面带上 new 调用，那么背地里将会创建一个新对象。新对象连接到该函数的prototype成员。12345678var Quo = function (string) &#123; this.status = string;&#125;Quo.prototype.get_status = function () &#123; return this.status;&#125;;var myQuo = new Quo('happy');document.writeln(myQuo.get_status()); Apply调用模式javascript是一门函数式的面向对象编程语言，所以函数可以拥有方法。 apply方法帮助我们构建一个参数数组传递给调用函数。它能帮助函数设置this。123456var statusObject = &#123; status: 'OK'&#125;;//让get_status方法内的作用域换成statusObject的作用域。var status = Quo.prototype.get_status.apply(statusObject);//status的值为OK。 call()方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 扩充类型功能Javascript允许给语言的基本类型扩充功能。而且给原型扩充时，是动态的。123456Function.prototype.method = function(name, func)&#123; if(!this.prototype[name])&#123;//如果方法已存在，就不添加 this.prototype[name] = func; &#125; return this;&#125;; 递归递归函数就是会直接或间接调用自身的函数。它把一个问题分为一组相似的子问题，每一个都用一个寻常解去解决。 ##作用域、闭包见我的另一篇文章]]></content>
      <categories>
        <category>Js进阶</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语言精粹(1)-精华与糟粕]]></title>
    <url>%2F2017%2F08%2F19%2Fjs%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(1)-%E7%B2%BE%E5%8D%8E%E4%B8%8E%E7%B3%9F%E7%B2%95%2F</url>
    <content type="text"><![CDATA[序本文是《Javascript语言精粹》的笔记和思考。 参考链接:SimplyY/blog 为什么要使用Javascript 你没有其他选择。web已变成一个重要的应用开发平台，而javscript是唯一一门所有浏览器都可以识别的语言。 javascript虽然有缺陷，但它真的很优秀。它既轻量又富有表现力。而且，你一旦掌握了它，就会发现函数式编程的魅力。任何语言都有精华和糟粕。我们要取其精华，弃其糟粕。况且，你有权利定义你自己的子集。我们完全可以基于精华部分去编写更好的程序。 Javascript优点 是弱类型语句。 有非常强大的对象字面量表示法。 基于原型继承的动态对象。 函数是顶级对象。函数可以调用方法。Javascript的继承可以借此特性实现。 Javascript缺点以解决办法使用 jshint 或者其他的一些 linter 插件工具来避免自己使用糟糕的特性。 全局变量 javascript依赖全局变量来进行连接。所有编译单元的所有顶级变量被撮合到名为“全局变量”的公共命名空间中。 可以使用es6的let，IIFE等方法解决。 + +的两个运算数只要一个不是 number 类型，+ 就会做字符串拼接。 parseInt(str, int) parseInt(str, int) 遇到非数字会自动停止解析，请一定加上第二个参数来设置进制. 不然假如第一个参数是零开头就会以8进制求值，比如”08”，返回零，因为8进制没有”8” 浮点数0.1 + 0.2 不等于0.310.3 - 0.1 // 0.19999999999999998 使用js库 https://github.com/MikeMcl/decimal.js123x = new Decimal(0.3)x.minus(0.1) // '0.2'x // '0.3' 判断value是不是数字1Number.isFinite('0'); //false 和全局的isFinite()函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。 1234567Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0) // true// 下面这几个如果使用全局的 isNaN() 时，会返回 true。Number.isNaN("NaN"); // false，字符串 "NaN" 不会被隐式转换成数字 NaN。Number.isNaN(undefined); // falseNumber.isNaN(&#123;&#125;); // false 和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。 js没有真正的数组123456typeof [] // 'object'//检测一个值是不是数组function isArray(value) &#123; return Object.prototype.toString.apply(value) === '[object Array]'&#125; null和undefined的区别null表示一个空值对象，即不存在的对象。当声明的变量还未被初始化时，变量的默认值为undefined。null还是一个对象，undefined就表示没有。 null典型用法是： 作为函数的返回值，表示该函数本应该返回对象，但是找不到，即为不存在的对象的意思。 作为对象原型链的终点。 调用函数时，作为缺省的参数。比如1Math.max.apply(null, array); undefined 典型用法是： 变量或对象属性被声明了，但没有赋值时，就等于 undefined。 调用函数时，未传入参数，函数内部该参数等于 undefined。 函数没有返回值时，默认返回 undefined。1Object.getPrototypeOf(Object.prototype); // null]]></content>
      <categories>
        <category>Js进阶</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less基础]]></title>
    <url>%2F2017%2F08%2F12%2Fless%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[less基础变量通过变量定义参数，然后在需要的时候直接调用。123456789101112131415161718// LESS@color: #4D926F;#header &#123; color: @color;&#125;h2 &#123; color: @color;&#125;/* 生成的 CSS */#header &#123; color: #4D926F;&#125;h2 &#123; color: #4D926F;&#125; 混合既然有了变量，自然少不了函数。就像js那样创建函数：1234567891011121314151617181920212223242526// LESS.rounded-corners (@radius: 5px) &#123; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius;&#125;#header &#123; .rounded-corners;&#125;#footer &#123; .rounded-corners(10px);&#125;/* 生成的 CSS */#header &#123; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px;&#125;#footer &#123; border-radius: 10px; -webkit-border-radius: 10px; -moz-border-radius: 10px;&#125; 嵌套通过在一个选择器中嵌套另一个选择器来实现继承，减少了代码量，并且代码看起来更加的清晰。1234567891011121314151617181920212223242526272829// LESS#header &#123; h1 &#123; font-size: 26px; font-weight: bold; &#125; p &#123; font-size: 12px; a &#123; text-decoration: none; &amp;:hover &#123; border-width: 1px &#125; &#125; &#125;&#125;/* 生成的 CSS */#header h1 &#123; font-size: 26px; font-weight: bold;&#125;#header p &#123; font-size: 12px;&#125;#header p a &#123; text-decoration: none;&#125;#header p a:hover &#123; border-width: 1px;&#125; 计算功能12345body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%; &#125; 继承SASS允许一个选择器，继承另一个选择器。比如，现有class1：123 .class1 &#123; border: 1px solid #ddd; &#125; class2要继承class1，就要使用@extend命令：1234 .class2 &#123; @extend .class1; font-size:120%; &#125; MORE阮一峰老师写的更加详细。 安装和设置加载器介绍一下如何在webpack里使用。 先设置module1234567891011121314module: &#123; loaders: [&#123; test: /\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\.(png|jpg)$/, loader: 'file-loader' &#125;, &#123; test: /\.scss$/, loaders: ["style", "css", "sass"] &#125;] &#125; 再安装loader1npm install sass-loader //如果报错说缺少什么，就安装什么 import用法如果你从另外一个文件中导入一个 LESS/SASS 文件，像其他地方一样使用准确的路径，Webpack 会找出那些文件，然后识别里面的依赖。1@import "./variables.scss"; 你也可以直接从你的 node_modules 文件夹中加载 LESS 文件。1$import "~bootstrap/less/bootstrap"; 总结实际使用的时候，记得保留字前加@，参数前加$。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>LESS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2017%2F08%2F11%2Fwebpack%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[webpack模块化开发webpack本身就是一款用户打包前端模块的工具。要了解它，首先要知道什么叫模块化开发。 前端开发中，起初只要在script标签中嵌入几十上百行代码就能实现一些基本的交互效果，后来js得到重视，应用也广泛起来了，jQuery，Ajax，Node.Js，MVC，MVVM等的助力也使得前端开发得到重视，也使得前端项目越来越复杂，然而，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，那么什么是模块呢？ 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 这就是模块化开发。而webpack能将依赖的模块转化成可以代表这些包的静态文件。 Webpack它的目标是什么？它和其他类似的工具有什么不同？webpack为什么要将所有资源放在一个文件夹里？详情请见《webpack学习之路》 webpack.config.js详解看代码说话：12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require('webpack');var path = require('path');var config_webpath_dev = require('./configs/webpack_dev');var config = &#123; resolve: &#123; alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125; &#125;, entry: ['./src/index'], output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurenceOrderPlugin() ], module: &#123; loaders: [&#123; test: /\.css$/, loaders: ['style', 'css'] &#125;] &#125;, devServer: &#123; contentBase: "./public", colors: true, historyApiFallback: true, inline: true, hot: true, host: config_webpath_dev.domain, port: config_webpath_dev.port &#125;,&#125;module.exports = config; resolve 这些选项能设置模块如何被解析alias配置项，可以为常用模块配置改属性，可以节省编译的搜索时间。例如：12345resolve:&#123; alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125; &#125; entry 是指入口文件的配置项，它是一个数组的原因是webpack允许多个入口点。output是指输出文件的配置项 path - 表示输出文件的路径 filename - 表示输出文件的文件名 plugins 顾名思义，使用插件可以给webpack添加更多的功能，使webpack更加的灵活和强大,webpack有两种类型的插件:webpack内置的插件12345678910// 首先要先安装webpack模块var webpack = require("webpack");module.exports = &#123; new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;)h&#125;; webpack外置插件1234567//npm install component-webpack-plugin 先要在安装该模版var ComponentPlugin = require("component-webpack-plugin");module.exports = &#123; plugins: [ new ComponentPlugin() ]&#125; 更多的插件以及插件的用法，大家可以到webpack的插件上查看。 module 决定了如何处理项目中的不同类型的模块。它通过配置要使用的loader，把资源文件（css、图片、html等非js模块）处理成相应的js模块,然后其它的plugins才能对这些资源进行下一步处理。比如babel-loader可以把es6的文件转换成es5。loaders 一个含有wepback中能处理不同文件的加载器的数组 test 用来匹配相对应文件的正则表达式 loaders 告诉webpack要利用哪种加载器来处理test所匹配的文件loaders 的安装方法1$ npm install xxx-loader --save-dev devServer(webpack-dev-server) 能够用于快速开发应用程序 color - Enables/Disables colors on the console. contentBase - 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。 historyApiFallback - 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html. hot - 启用 webpack 的模块热替换特性. inline - 默认情况下，应用程序启用内联模式(inline mode)。这意味着一段处理实时重载的脚本被插入到你的包(bundle)中，并且构建消息将会出现在浏览器控制台。 host - 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问，指定如下： port - 指定要监听请求的端口号]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS要点]]></title>
    <url>%2F2017%2F08%2F09%2Fcss%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[CSS要点《css设计指南》笔记 HTMLsection只有元素内容会被列在 文档大纲 中时，才适合用section元素。 这里的文档大纲更像是提纲，section 就是提纲中的不重复项（比如对于博文 list，整个 list 才属于一个 section） 块级元素和行内元素块级元素盒子会扩展到与父元素同宽 明确设定 width 属性后，块级元素就不会再扩展到与父元素(即 body)同宽了。没有设定 width，值为 auto。行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。 CSS伪类伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。 UI伪类会在 HTML 元素处于某个状态时(比如鼠标 指针位于链接上)，为该元素应用 CSS 样式。 结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第一个或最后一个)，为相应元素应用 CSS 样式。UI伪类 链接伪类(link 未被点，visited 已被点，hover 鼠标悬停，active 正在被点) :focus 伪类 表单中的文本字段在用户单击它时会获得焦点，获得焦点时使用 css 样式。 :target 伪类，用户点击一个指向页面中其他元素的链接。常用于页面内跳转里，来显示跳转到的位置，使用举例1&lt;a href="#more_info"&gt;More Information&lt;/a&gt; 位于页面其他地方、ID 为 more_info 的那个元素就是目标。该元素可能是这样的:1&lt;h2 id="more_info"&gt;This is the information you are looking for.&lt;/h2&gt; 那么，如下 CSS 规则1#more_info:target &#123;background:#eee;&#125; 会在用户单击链接转向 ID 为 more_info 的元素时，为该元素添加浅灰色背景。 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。 ::first-letter 伪元素 :1p::first-letter &#123;font-size:300%;&#125; 可以得到段落首字符放大的效果。 ::first-line 伪元素 ::before 和::after 伪元素 :12p.age::before &#123;content:"Age: ";&#125;p.age::after &#123;content:" years.";&#125; 伪类与伪元素的区别伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 权重浏览器通过权重来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。 权重是如何计算的？优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。 而当优先级与多个CSS声明中任意一个声明的优先级相等的时候，CSS中最后的那个声明将会被应用到元素上。 当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的CSS规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。 MORE 盒模型每一个元素都会在页面上生成一个盒子。因此，HTML 页面实际上就是由一堆盒子组成的。 重置样式表1* &#123;margin:0; padding:0;&#125; box-sizing当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。 浮动和清除浮动，你看这俩字儿多形象，意思就是把元素从常规文档流中拿出来。 拿出 来干什么?一是可以实现传统出版物上那种文字绕排图片的效果，二是可以让原来 上下堆叠的块级元素，变成左右并列，从而实现布局中的分栏。 当你浮动一个元素的时候……这些(浮动)规则就好像 在说:“尽量把这个元素往上放，能放多高放多高，直到碰到某个元素的边界为止。” 对.clearfix的理解浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。父元素会收缩到没它一样。这往往混乱页面的布局。所以我们需要使父元素围住浮动元素。我主要解释一下添加非浮动的清除元素这一方法。 这种方法可以通过简单的给父元素（或者最后一个浮动元素）加上 class=”clearfix” 做到。1234567.clearfix:after &#123; content:"."; display:block; height:0; visibility:hidden; clear:both;&#125; 它只添加一个清除的包含句点为非浮动元素。规则中的其他声明只是为了确保这个伪元素没有高度，且不可见。就像有条看不见的分割线，拦住了从下往上冲的元素。 clearfix大法好。该方法最早由程序员TonyAslett发明。 背景 background-color background-image background-repeat background-position background-size background-attachment background(简写属性) 背景图片123p &#123; background-image:url(images/turq_spiral.png);&#125; 背景重复repeat(默认),repeat-x,repeat-y,no-repeat. 背景位置123p#center &#123; background-position:center;//top,left,bottom,right&#125; 多背景图片12345p &#123; background: url(images/turq_spiral.png) 30px -10px no-repeat, url(images/pink_spiral.png) 145px 0px no-repeat, url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75; &#125; 背景渐变线性渐变12345678.gradient1 &#123;background:linear-gradient(#e86a43, #fff);//从上到下&#125;.gradient3 &#123; background:linear-gradient(-45deg, #e86a43, #fff);//从左上到右下&#125; .gradient2 &#123; 1 background:linear-gradient(left, #64d1dd, #fff);&#125; 渐变点12345678.gradient1 &#123; background:linear-gradient(#e86a43 20%, #fff 50%, #e86a43 80%); &#125;.gradient3 &#123; background:linear-gradient(#64d1dd, #fff 25%, #64d1dd 50%, #fff 75%, #64d1dd);&#125;.gradient4 &#123;background:linear-gradient(#e86a43, #fff 25%, #64d1dd 25%, #64d1dd 75%, #fff 75%, #e86a43);&#125; 放射性渐变123456789.gradient1 &#123;background: -webkit-radial-gradient(#fff, #64d1dd, #70aa25); &#125;.gradient2 &#123; background: -webkit-radial-gradient(circle, #fff, #64d1dd, #e86a43); &#125;.gradient3 &#123; background: -webkit-radial-gradient(50px 30px, circle, #fff, #64d1dd,#4947ba); &#125; 字体和文本字体族1body &#123;font-family: "Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;&#125; 在指定文本的字体时，需要多列出几种后备字体， 以防第一种字体无效。这个字体的列表也叫字体栈。 字体类 serif，也就是衬线字体 sans-serif，也就是无衬线字体 monospace，也就是等宽字体 cursive，也就是草书体或手写体 fantasy，不能归入其他类别的字体(一般都是奇形怪状的字体)。使用这些通用字体类的目的，就是确保在最坏的情况下，文档起码可以通过正确的字形来显示，将通用字体类写到最后即可。 字体样式值:italic、oblique、normal。 示例:h2 {font-style:italic;} 。 文本属性 文本缩进: text-indent 字符间距: letter-spacing 单词间距: word-spacing 文本对齐: text-align，值:left、right、center、justify。 行高: line-height 文本装饰: text-decoration，值:underline、overline、line-through、none。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的重要性]]></title>
    <url>%2F2017%2F07%2F23%2FCSS%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS玉伯看HTML和CSS代码的背后https://github.com/lifesinger/blog/issues/105&gt; 之前在freeCodeCamp上看到两篇置顶的前端入门文章。第一篇的内容涉及html和css。第二篇就讲javascritpt。看第一篇内容时，真是被文章丰富的内容吓了一跳。当时心里就嘀咕，真的要学这么多吗？ 直到今天看了玉伯的文章，才意识到html和css同样非常重要。所以，特地做一下笔记，把所思所想理一下。 让块元素水平居中。一般大家都会写成：1234.content &#123; width: 980px; margin: 0 auto;&#125; 上面的代码能正常工作，大部分情况下也不会有问题，但上面的代码存在思维的懒惰。应该写成:12345.content &#123; width: 980px; margin-left: auto; margin-right: auto;&#125; 看起来代码变多了，变啰嗦了。但如果你真的了解 margin: 0 auto 的话，就能明白其中的意义。 margin: 0 auto 的实现：123456&#123; margin-top:0; margin-bottom:0; margin-left:auto; margin-right:auto;&#125; 可以看到 margin: 0 auto 中会帮你把top和bottom重置了。可是，你只想要“水平居中”而已。 这种不纯粹会导致顺序和优先级的依赖，比如有另一处要给 margin-top/bottom 赋值时，就必须要提高优先级。 而且 margin: 0 auto 中的 0 绝大部分情况下是冗余的，页面上早就有 reset.css 或 normalize.css 重置过。 最小影响原则你在写某段CSS代码时，首先要非常清楚地知道这段CSS代码的功能，其次要尽量严格保障这段CSS代码只实现了你想要实现的功能。 这就如医生动手术，好好做好本分就行，千万别留下一个小镊子在病人身体里。 与HTML代码一样，对CSS代码来说，很重要的两个衡量标准也是稳定和灵活。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js基础：作用域、闭包、this]]></title>
    <url>%2F2017%2F07%2F22%2FJs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81this%2F</url>
    <content type="text"><![CDATA[作用域词法作用域：描述了源代码中的范围。 if语句或while语句以及其他类似循环结构的语句块不能创建新的作用域。只用function语句块能创建新的作用域。 执行环境：当程序运行的时候，会创建一个存储变量和变量值的存储系统。这些内存中的作用域结构被称为执行环境。 执行环境和词法作用域的不同：执行环境实在程序运行时才被创建的，不是在代码输入时被创建的。执行环境能控制在程序执行过程中不同点能访问哪些变量。注：12345var test=function()&#123;&#125;;var test1=test();var test2=test();log(test1===test2);//falsejavascript不对对象进行引用 闭包闭包是指一些函数通过某种方式可以随时被访问，即使它的外部代码已经执行完毕。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 常见的闭包的现象，如通过函数字面量创建的函数对象包含一个连到外部上下文的连接。 保留函数访问权限的方法 passing to setTimeout 从函数中return 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 保存为全局变量 用处 设计模块中的私有属性和方法（闭包中的自由变量无法被直接访问） 让这些变量的值始终保持在内存中(可以被延迟调用，比如事件 handler，ajax 异步调用的回调函数等)。 Thisthis指调用函数的那个对象 使用new的时候会发生什么 创建一个新的空对象；//Object.create(); 将this绑定到该对象； 添加一个名为proto的新属性，并且指向构造函数的原型(prototype)； 返回该this对象。//return this; this的用法 纯粹的函数调用: this 就代表全局对象 Global（浏览器下就是 window）。 作为对象方法的调用: this 指向调用方法的对象。 作为构造函数调用：this 就指向 构造器创建的新对象 apply, call, bind调用：this 指向就是这些函数的第一个参数 原型链当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止（这种行为我们也称之为委托）。 原型链是使用其他对象属性的一种方式。 原型链的属性复制发生在当前查找的时候，所以是实时更新的。 Javascript为什么会有prototype]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法基础：Array、String常用方法]]></title>
    <url>%2F2017%2F07%2F22%2FJs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%9AArray%E3%80%81String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray.prototype.concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。123var one=['a','b'];var two=['d','c'];var three=one.concat(two);//three[a,b,c,d] one[a,b] two[c,d] 描述 concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里. 简单的说 concat不修改原数组 concat是浅复制，只是对于数组包含的元素的复制。 队列、堆栈Array.prototype.shift()shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 Array.prototype.unshift()The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array. Array.prototype.push()The push() method adds one or more elements to the end of an array and returns the new length of the array. Array.prototype.pop()The pop() method removes the last element from an array and returns that element. This method changes the length of the array. Array.join(separator)数组格式化输出，返回字符串。以 separator 分隔，separator 默认为’,’1[1,2,3].join(' ') // '1 2 3' Array.prototype.slice(begin,end)返回数组中的一部分的浅复制到一个新的数组对象，只对数组中的元素进行浅复制。原始数组不会被修改。12345var a = ['zero', 'one', 'two', 'three'];var sliced = a.slice(1, 3);console.log(a); // ['zero', 'one', 'two', 'three']console.log(sliced); // ['one', 'two'] Array.prototype.splice(start, deleteCount, items…)splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 高阶函数Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 Array.prototype.reduce()reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array)&#123; return accumulator + currentValue;&#125;);// 10 描述reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： accumulator 初始值（或者上一次回调函数的返回值） currentValue 当前元素值 currentIndex 当前索引 array 调用 reduce 的数组。 回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 callback 函数会被自动传入三个参数：当前数组元素，当前元素索引，原数组本身 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] Array.prototype.filter()The filter() method creates a new array with all elements that pass the test implemented by the provided function. 1234567var words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];var longWords = words.filter(function(word)&#123; return word.length &gt; 6;&#125;)// Filtered array longWords is ["exuberant", "destruction", "present"] [数组的其他方法和属性]（https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array）Stringstring.charAt(pos)返回只含一个字母的字符串 string.indexOf(searchString, position)返回字符串里面的字母所在的位置下标，实际上把把 string 看成一个 char[]，更容易理解 string.slice(start, end)返回子字符串，参数可以为负数 string.match(regexp)返回比配字符串，假如有正则表达式为/xxx/g则，返回一个数组，否则返回第一次匹配到的字符串 string.replace(searchValue, replaceValue)替换字符串，searchValue 可以为正则表达式。]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人工智能狂潮》摘记]]></title>
    <url>%2F2017%2F05%2F23%2F%E3%80%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8B%82%E6%BD%AE%E3%80%8B%E6%91%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《人工智能狂潮》摘记第一次人工智能狂潮的局限（20世纪60年代）计算机只能解决所谓的“玩具问题”。求解迷宫问题，挑战国际象棋及将棋，这些都只需要在明确定义好的规则中考虑下一步如何走起即可，然而，现实生活中的问题却要复杂得多。 第二次人工智能狂潮的局限（20世纪80年代末）永无穷尽的知识Example: He saw a woman in the garden with a telescope. 理解这句话，需要一般性的常识。而计算机要处理一般性的常识，就需要掌握人类所拥有的，永运也无法写尽的海量知识，这是极其困难的。因为，同样的事情在所有的各种各样的场合皆会发生。 框架问题框架问题，就是执行某项任务时“仅仅提取出与它相关的知识并对其加以运用”，这对人类来说简单的事，但对计算机来说是困难无比的。 符号接地问题是否能将符号（词语,语言）与它所表示的意义连接起来。 日本在1982年启动了名为“第五代计算机”的国家级项目，从1982年开始前后跨越了10年，总共投入了570亿日元。尽管没有实现预定目标，但是它聚集了人工智能研究的优秀人才，还吸引了众多的海外知名专家，并由此建立了相关的人才联系网络。 第三次人工智能狂潮（机器学习，深度学习）机器学习的难点特征量的设计必须由人来做。特征量，指的是机器学习在输入时所使用的变量，其值是对对象特征的定量表示。 深度学习之后]]></content>
      <categories>
        <category>编程之外</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读Android原生计算器源码]]></title>
    <url>%2F2017%2F05%2F17%2F%E9%98%85%E8%AF%BBAndroid%E5%8E%9F%E7%94%9F%E8%AE%A1%E7%AE%97%E5%99%A8%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Read Android Original Calculator项目结构 Calculator CalculatorPadLayout CalculatorNumericPadLayout CalculatorPadViewPager CalculatorExpressionBuilder CalculatorExpressionEvaluator CalculatorExpressionTokenizer CalculatoronBackPressed()处在第高级操作符页面时，点击back键，返回初始页面。 onUserInteraction()Called whenever a key, touch, or trackball event is dispatched to the activity. 在处理用户交互前，如果由正在进行的动画请立即终止。 onEquals()至于计算，只要获得式子的字符串，然后交给 org.javia.arity.Symbol就行了。12//一句话的事double result = mSymbols.eval(expr); CalculatorPadViewPager为什么在显示page1的时候page2会显示出来一部分呢（右侧青色那一条）？答案在setPageMargin(-24);由于是负数，这样每个page之间就会有重叠，就出现了明明显示的第一个view，结果在右侧显示了一部分第二个view的layout。 为什么向左滑动的时候page1的位置一直保持不动？不应该是向左侧滑出吗？看setPageTransformer(false, mPageTransformer); 123456789/*** Apply a property transformation to the given page.** @param page Apply the transformation to this page* @param position Position of page relative to the current front-and-center* position of the pager. 0 is front and center. 1 is one full* page position to the right, and -1 is one page position to the left.*/public void transformPage(View page, float position); 看一下源码里的方法说明，这里的position其实是相对的，并不是常规理解的位置下标，它是以当前屏幕的正中心为坐标原点，当page的中心和屏幕的原点重合（即page正在完全显示时）position=0;当page向左侧滑动，慢慢淡出屏幕时，该过程中page的中心相对屏幕的中心原点在沿着X轴向左移动，此时positon &lt; 0，当page完全滑出屏幕时，positon = -1;同理，当page向右滑动，慢慢淡出屏幕时，该过程中page的中心相对屏幕的中心原点在沿着X轴向右移动，此时positon &gt; 0，当page完全滑出屏幕时，positon = 1； 有了上面的分析，其实可以把positon看成正在滑动的page滑出屏幕的比例，正负代表往哪个方向滑动。所以，要想在滑出数学计算公式的page过程中保持当前输入的page位置不动，根据滑出屏幕的比例设置该page在X轴的偏移量就可以了，view.setTranslationX(getWidth() * -position); 同理，把数学计算公式的page滑出时取消这个偏移量，view.setTranslationX(0); 到这里疑问2也解决了。 更多的ViewPager切换动画请参考开源项目JazzyViewPager 还有就是当page2滑出后宽度为什么没有铺满、左边还要留出一部分透明区域呢？原来是复写了PagerAdapter的getPageWidth方法，看一下该方法的说明： 12345678910/** * Returns the proportional width of a given page as a percentage of the * ViewPager's measured width from (0.f-1.f] * * @param position The position of the page requested * @return Proportional width for the given page position */public float getPageWidth(int position) &#123; return 1.f;&#125; 说的很清晰了，根据position设置当前页面宽度的百分比。 123public float getPageWidth(int position) &#123; return position == 1 ? 7.0f / 9.0f : 1.0f; &#125; OnPageChangeListener解读Callback interface for responding to changing state of the selected page. OnPageChangeListener这个接口需要实现三个方法：（onPageScrollStateChanged，onPageScrolled ，onPageSelected）：onPageScrollStateChanged(int arg0) ，此方法是在状态改变的时候调用，其中arg0这个参数。有三种状态（0，1，2）。arg0 ==1的时辰默示正在滑动，arg0==2的时辰默示滑动完毕了，arg0==0的时辰默示什么都没做。 onPageScrolled(int arg0,float arg1,int arg2) ，当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为： arg0 :当前页面，及你点击滑动的页面 arg1:当前页面偏移的百分比 arg2:当前页面偏移的像素位置 onPageSelected(int arg0) ： 此方法是页面跳转完后得到调用，arg0是你当前选中的页面的Position（位置编号）。 CalculatorPadLayout自定义了数字键盘的布局。规定了每个按键的长宽高，以及位置。 CalculatorNumericPadLayout extends CalculatorPadLayout根据id设置按钮属性。 总结原本不知道怎么实现的效果，发现方法其实很简单。当然，你得对源码很了解，才能想到。 小要点SpannableStringBuilderThis is the class for text whose content and markup can both be changed TextWatchWhen an object of a type is attached to an Editable, its methods will be called when the text is changed.]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Contentprovider]]></title>
    <url>%2F2017%2F04%2F28%2F%E7%90%86%E8%A7%A3Contentprovider%2F</url>
    <content type="text"><![CDATA[How to use content providerwhat is a content provider?content provider是位于应用和其数据源之间地类。它能让应用轻松地访问相关数据源，并且访问过程得到管理。 why is it useful? 作为额外地抽象化操作，它允许开发者更改相关数据源，而不用更改访问内容提供器地应用中地代码。 SyncAdapters，Loaders，CursorAdapter需要通过contetn provider 访问数据。 向其他应用开发数据源，使他们能够访问，使用修改你的数据源。 用途： 提取基础数据，安全高效地跨应用边界分享数据 轻松地切换数据源，而且更便于他人管理UI层代码 向小部件发送数据，或从更新的应用返回搜索结果 有效地与服务器同步，并在UI层实时更新 ContentResolverContentResolver使应用与正确的ContentProvider沟通。 Cursorcursor是一种迭代器，使程序能够以表格的形式访问相关数据。 SimpleExample：12345678910111213141516171819// Get the TextView which will be populated with the Dictionary ContentProvider data. ListView dictListView = (ListView) findViewById(R.id.dictionary_list_view); // Get the ContentResolver which will send a message to the ContentProvider. ContentResolver resolver = getContentResolver(); // Get a Cursor containing all of the rows in the Words table. Cursor cursor = resolver.query(UserDictionary.Words.CONTENT_URI, null, null, null, null); // Set the Adapter to fill the standard two_line_list_item layout with data from the Cursor. SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.two_line_list_item, cursor, COLUMNS_TO_BE_BOUND, LAYOUT_ITEMS_TO_FILL, 0); // Attach the adapter to the ListView. dictListView.setAdapter(adapter);]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
