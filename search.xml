<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript中的多态和继承]]></title>
    <url>%2F2017%2F09%2F22%2FJavascript%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[说点历史了解Javascript的都知道，除了几个简单的数据类型，剩下的所有数据类型在Javascript中都是对象。之所以会这样，是因为Js诞生于面向对象思想最兴盛的时期。Js之父Brendan Eich无疑受到了影响。 面向对象的思想如此的火热，以至于出现了一些狂热的言论，如没用使用面向对象思想的程序都是过时的设计。这些言论当然是荒谬的，但不得不承认面向对象的变革推动了一些概念的流行。其中最重要的概念就是封装（将内部复杂性与外部接口切割开来)，而对象正是这一概念最鲜明的体现。 有了封装，才有了多态和继承等概念，可见其重要性。 封装对象就像一个坚硬的外壳，它隐藏了其内部的复杂性，并提供给我们一些旋钮和接口（如方法）作为操作对象的接口。这一想法就是封装的具体体现。 多态接口的多种不同的实现方法即为多态。 Javascript中多态是通过组合和虚函数来实现的。构造函数接受函数作为参数，来自定义自己的接口。 12345678910111213141516171819202122232425262728293031323334353637//父对象function TextCell(text) &#123; this.text = text.split("\n");&#125;TextCell.prototype.minWidth = function() &#123; return this.text.reduce(function(width, line) &#123; return Math.max(width, line.length); &#125;, 0);&#125;;TextCell.prototype.minHeight = function() &#123; return this.text.length;&#125;;TextCell.prototype.draw = function(width, height) &#123; var result = []; for (var i = 0; i &lt; height; i++) &#123; var line = this.text[i] || ""; result.push(line + repeat(" ", width - line.length)); &#125; return result;&#125;;//子对象function UnderlinedCell(inner) &#123; this.inner = inner;&#125;UnderlinedCell.prototype.minWidth = function() &#123; return this.inner.minWidth();&#125;;UnderlinedCell.prototype.minHeight = function() &#123; return this.inner.minHeight() + 1;&#125;;UnderlinedCell.prototype.draw = function(width, height) &#123; return this.inner.draw(width, height - 1) .concat([repeat("-", width)]);&#125;;var underlinedCell = new UnderlinedCell(new TextCell(name)); 如上，通过把TextCell对象传入UnderlinedCell构造函数进行组合。而像minHeight、 minWidth这类在父类和子类有不同实现的函数为虚函数。所以说Js中多态的实现靠组合和虚函数。 继承当你像构造出与当前类型相似的类型时，可以通过继承来实现。 Js中的继承有多种实现，这里只介绍寄生组合式继承这一种。123456789101112131415161718192021222324252627// Shape - superclassfunction Shape() &#123; this.x = 0; this.y = 0;&#125;// superclass methodShape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info('Shape moved.');&#125;;// Rectangle - subclassfunction Rectangle() &#123; Shape.call(this); // call super constructor.&#125;// subclass extends superclassRectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle; // for rect instanceof Rectangle === truevar rect = new Rectangle();console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle);// trueconsole.log('Is rect an instance of Shape?', rect instanceof Shape);// truerect.move(1, 1); // Outputs, 'Shape moved.' 其实呢，我们天天在用的 array、object 的继承关系和上面的代码如出一辙，看下图，Shape 相当于 Object，Rectangle 相当Array:]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识动态规划]]></title>
    <url>%2F2017%2F09%2F16%2F%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划的基本思想动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。在实际情况中，可以用一个表记录所有已解的子问题的答案。 动态规划的适用情况 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 问题具有最优子结构性质，我们才能写出最优解的递归方程；具有重叠子问题特性，我们才能通过避免重复计算来减少运行时间。 综上所述，动态规划的关键是 —— 记忆，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。 实例斐波那契数列只用递归来实现：123var fibonacci = function(n) &#123; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125; 这种实现不会记录先前操作的结果，每次求值都会进行无谓的重复运算。通过给它添加记忆，来优化它的时间复杂度:123456789101112var fibonacci = function () &#123; var memo = [1, 2]; var fib = function (n) &#123; var res = memor[n]; if(typeof res !== 'number') &#123; res = fib(n-1) + fib(n-2); memo[n] = res; &#125; return res; &#125;; return fib;&#125;(); 通过创建一个名为memo的数组，来保存子问题的结果。memo保存在闭包中。当函数调用时，就会首先检查memo数组，如果已经存在，就直接返回结果。 总之，这个例子很好的说明了动态规划的关键，即用空间换时间。 01背包01背包是动态规划中比较简单的一个问题。理解它，能清楚动态规划两个重要概念：状态和状态转移方程。 假设编号分别为a,b,c,d,e的五件物品，重量分别是2,2,6,5,4，价值分别是6,3,5,4,6，现在有一个承重为10的背包，如何装入物品具有最大价值？ 思路分析首先我们来找状态。动态规划的一个重要思路就是把大问题分解成小问题。小问题除了规模更小，本质上还是相同的问题。我们可以从承重为0的背包开始，再逐渐增加到承重为10的背包。具体情况，结合下图讲解： 当背包的体积为2，行数为2时，求的是前两个物品a,b装入背包里能达到的最大值。当背包的体积为8，行数为5时，求的是前5个物品装入背包能达到的最大值。有没有发现，以上句子都是一个句式。形式化的表示它们，定义d(i,j)为前i 个物品装到剩余体积为j的背包里能达到的最大值。那么上面两句即为：d(2,2)和d(5,8)。这样看是不是简洁多了。这两个符号就是我们要找的状态，即状态d(i,j)为前i 个物品装到剩余体积为j的背包里能达到的最大值。 上面那么多的文字，用一句话概括就是：根据子问题定义状态！你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为d(n, C)：前n个物品 （0,1,2…,n-1）装入剩余容量为C的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。 要明白状态转移方程，你要明白上面的表格是这么填的。随便挑一个表格(a，9)，此时背包容量为9，可以选abcde五种物品，我们要找出容量的最大值，对待每个物品的具体策略是放入物品a和不放入物品a这两种情况： 情况a: 假如放入物品a, 则背包容量变为9-2=7，还剩b,c,d,e四种物品。所以该情况下的最大值 = (b,7) + 物品a的价值6，即9+6。 情况b: 假如不放入物品a, 背包容量不变为9，还剩b,c,d,e四种物品。所以该情况下的最大值 = (b, 9)，即10。 所以现在(a, 9) = max( (b,7)+6, b(9) ) = max(9+6，10) = 15。max( (b,7)+6, b(9) )就是状态转移方程的具体体现。 代码实现12345678910111213141516171819202122function packageMaxValue(weight, value, size) &#123; // 省略参数合法性校验 let bagMatrix = [] for(let w = 0; w &lt;= size; w++) &#123;//size是背包的大小 // js不能直接创建二维数组，所以在此初始化数组 bagMatrix[w] = [] for (let j = 0; j &lt; 5; j++) &#123; // 背包的容量为0，那么一个东西也装不下，此时的值肯定也是为0 if(w === 0) &#123; bagMatrix[w][j] = 0 continue &#125; // 背包的容量小于物品j的重量，那么就没有上述情况a了 if(w &lt; weight[j])&#123; bagMatrix[w][j] = bagMatrix[w][j-1] || 0 continue &#125; bagMatrix[w][j] = Math.max((bagMatrix[w-weight[j]][j-1] || 0) + value[j], bagMatrix[w][j-1] || 0) &#125; &#125; return bagMatrix&#125; 参考链接： 动态规划之背包问题（一） js实现01背包问题]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[what is vanilla-js]]></title>
    <url>%2F2017%2F09%2F15%2Fwhat-is-vanilla-js%2F</url>
    <content type="text"><![CDATA[最强大的JS库——Vanilla JSjavascript的世界里有一个叫做Vanilla JS的库。 它声称自己是占有率最高的库。各大顶级公司，如Facebook、Google、Amazon等都在使用它。它的官方文档里还说自己的使用量是Jquery、Prototype、YUI。。。的总和还多。这是要逆天的节奏啊！然而，这么牛逼的东西，我竟然一无所知？ 还没完呢。当你准备下载它时，它说完全没有这个必要。因为，Vanilla JS太牛逼以致所有的浏览器都内置了。我靠，这么厉害的库为毛我压根就没听说过，就算我只是个新手，多少有点耳闻把！ 除了使用量，衡量一个库的重要指标就是速度了。下面是Vanilla JS与其他库的速度对比：我擦！ 好吧，竟然这么牛逼，算我见识少。让我Google一下看看这到底是什么玩意。 搜索结果还不少，看来确实很有名。 随便选篇中文文章看看。 额。。。好吧，作者原来和我一样，也被忽悠地一愣一愣的。 Vanilla JS的另一个名字是Javascript。。。。。。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>轻松一刻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript语言精粹：方法（2）]]></title>
    <url>%2F2017%2F09%2F13%2FJavascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%EF%BC%9A%E6%96%B9%E6%B3%95%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[序文章包含Function、Number和Object的一些常用API的实现和说明。 Functionfunction.bind(thatArg)123456789Function.method('bind',function (that) &#123; var method = this, slice = Array.prototype.slice, args = slice.apply(arguments,[1]);//获得除this以外的参数 return function() &#123; return method.apply(that, args.concat(slice.apply(arguments, [0]))); &#125;;&#125;) apply、callapply或call是用来指定某个方法的作用对象的。换句话说，就是为了改变函数体内部 this 的指向。 像“slice.apply(arguments,[1])”这样的语句，使arguments拥有了slice方法，虽然arguments只是个类数组。 所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（如arguments），但是其他的有（上面的例子中Array有slice方法），我们可以借助call或apply用其它对象的方法来操作。 bind我们先看一下MDN的解释： bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. js的世界中，函数内的this会因为调用方式的不同，而发生改变。所以,常使用bind来固定函数的上下文。当然，你也可以通过函数内的变量保存上下文，来达到相同的效果。 另外，一个函数多次调用bind方法，函数内的this一直是第一次绑定的值，不会改变。 apply、call和bind的区别那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个例子：12345678910111213var obj = &#123; x: 81,&#125;;var foo = &#123; getX: function() &#123; return this.x; &#125;&#125;console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81 三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。 也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 再总结一下： apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 Numbernumber.toFixed(fractionDigits)toFixed方法把number转换成为一个十进制的字符串。fractionDigits这个参数用来设置保留几位小数。 number.toPrecision(precision)和toFixed不同的是，toPrecision决定数字的长度。toFixed决定的是小数点后的长度。 number.toString(radix)参数radix用来控制返回的number字符串的进制。 ObjectObject.hasOwnProperty(name)该方法用来判断对象是否包含name属性。原型链不会被检查到。这个方法对name是hasOwnProperty的无效，此时返回false。 参考链接 深入浅出妙用 Javascript 中 apply、call、bind]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript语言精粹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript语言精粹：方法（1）]]></title>
    <url>%2F2017%2F09%2F12%2FJavascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%EF%BC%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[序这篇文章包含一些数组API的实现，以及看书时的一些联想。 未解决的问题 array的很多api的实现都基于.splice()。.splice()的优点在哪？希望知道的朋友能解答一下。Arrayarray.slice(start, end) And array.concat(item…)12345var a = [1, 2, 3], c1 = [].concat(a), c2 = a.slice(0); 以上这两种copy方法在性能上相差无几。为了便于理解，推荐使用slice()。 array.pop()、array.shift()、array.unshift()pop的实现：123Array.method('pop',function ()&#123; return this.splice(this.length-1,1)[0];&#125;); shift的实现：123Array.method('shift',function() &#123; return this.splice(0, 1)[0];&#125;); unshift的实现：12345678Array.method('unshift', function() &#123; this.splice.apply( this, [0, 0] .concat(Array.prototype.slice.apply(arguments)) ); return this.length;&#125;); array.push(item…)push的实现：12345678Array.method('push',function ()&#123; this.splice.apply( this, [this.length, 0] .concat(Array.prototype.slice(arguments)) ); return this.length;&#125;); 解释一波，分成三部分： Array.prototype.slice(arguments)帮你把类数组转化成数组。如果你直接将arguments传入，arguments会被当作一个整体加入。原数组的长度只会加1： array 0 ：“c” 1 ：[Array(2), true, {…}] //arguments 也就是没有拆分好arguments。当然你可以通过arguments索引,再配上for一个一个地加入。但是多麻烦，直接用slice()多好。 [this.length,0].concat(#1)就是帮你产生一个新数组。新数组的前两位作为splice的前两个参数，即start和deletcount。 最后一步，用this.splice.apply(this, #2)修改原数组。这里splice不是用来删除的，是用来添加的。 array.sort(comparefun)只能排序数字：123num.sort(function(a, b)&#123; return a - b;&#125;); 还能排序字符串：123456789num_str.sort(function(a, b) &#123; if(a === b) &#123; return 0; &#125; if(typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1;&#125;); 再给力点，能排序数组对象：1234567891011121314151617181920212223242526272829//by函数接受一个作为比较的成员名字符串参数。//返回一个排序对象数组的比较函数var by = function (name) &#123; return function (o, p) &#123; var a, b; if(typeof o === 'object' &amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) &#123; a = o[name]; b = p[name]; if( a === b ) &#123; return 0; &#125; if( typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125; else &#123; throw &#123; name: 'Error', message: '期望通过'+name +'排序对象数组' &#125;; &#125; &#125;;&#125;;var s = [ &#123;first: 'Joe', last: 'Besser'&#125;, &#123;first: 'Moe', last: 'DeRita'&#125;];s.sort(by('first')); 如果想基于多个键值进行排序：123456//只要修改：if(a === b) &#123; return typeof secondParam === 'function' ? secondParam (o, p) : 0;&#125;s.sort(by('first',by('last'))); array.reduce()1234567Array.method('reduce', function(f, value) &#123; var i; for(i =0; i&lt;this.length; i++) &#123; value =f(this[i],value); &#125; return value;&#125;); array.splice(start, deleteCount, item…)splice 是我最喜欢的原生数组函数，只需要调用一次，就允许你删除元素、插入新的元素，并能同时进行删除、插入操作。需要注意的是，不同于`.concat和.slice,这个函数会改变源数组。 .splice会返回删除的元素。如果你想遍历已经删除的数组时，这会非常方便。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript语言精粹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript语言精粹: 数组]]></title>
    <url>%2F2017%2F09%2F11%2FJavascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%3A%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[序在C++、Java中，数组是一段线性分配的内存。它通过整数计算偏移并访问其中的元素。这样的数组是一种性能出色的数据结构。可惜，javascript中没有像此类数组一样的数据结构。 javascript中的数组是一个拥有数组特性的对象。它把数组的下标转换成字符串，用其作为属性。这使它明显比一个真正的数组慢，但它使用起来更方便。它的属性的检索和更新的方式与对象一样，只是多了一个可以用整数作为属性名的特性。 数组基础数字字面量像对象、函数都有字面量一样，数组也有它的字面量。12345678var empty = [];var numbers = [ 'zero', 'one', 'two', 'three'];empty[1] //undefinednumbers[1] //oneempty.length //0numbers.length //4 我开头就说过javascript中的数组也是对象。现在就用对象字面量创建一个数组：123var numbers_object = [ '0': 'zero', '1': 'one', '2':'two', '3':'three'] 两者产生的结果相似。但是两者有着显著的不同。numbers继承Array.prototype,numbers_object继承Object.prototype。除此之外，numbers还有个length属性。 说到length，不得不说javascript的length很奇葩。为什么，接着看。 长度 javascript中的length是没有上界的。length会随着数组容量的增大，而自动增大，不会发送数组越界错误。不过ECMAScript262的标准规定，数组的下标必须在0到231之间。 你可以直接设置length值。什么情况，自己设置length。对，想想length只是个属性而已，就没什么奇怪了。length设得过大，不会给数组分配更多的空间。如果设小了，会删除下标大于等于新length的属性。 容易混淆的地方既然数组是对象，拿什么时候用数组，什么时候用对象呢？当属性名是小而连续的整数时，你应该使用数组。否则，使用对象。 怎么区分数组和对象呢？123var is_array = function (value) &#123; return Object.prototype.toString.apply(value) === '[object Array]';&#125;; 多维数组和初始化初始化javascript的数组通常不会预置值。如果你需要预置值的话，要自己准备：1234567Array.dim = (len, init) =&gt; &#123; var a=[], i; for (i=0; i&lt;len; i++) &#123; a[i] = init; &#125; return a;&#125; 多维数组javascript没有多维数组，但是就像大多数C语言一样，它支持元素为数组的数组。1234567891011121314//构造多维数组Array.matrix = (m, n, init) =&gt; &#123; var a, i, j, mat = []; for (i=0; i&lt;m; i++) &#123; a = []; for(j=0; j&lt;n; j++) &#123; a[j] = init; &#125; mat[i] = a; &#125; return mat&#125;//构造一个初始值为0的4X4矩阵。var myMatrix = Array.matrix(4, 4, 0);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript语言精粹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上手Promise]]></title>
    <url>%2F2017%2F09%2F10%2F%E4%B8%8A%E6%89%8BPromise%2F</url>
    <content type="text"><![CDATA[前言在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数来实现。常见的例子如AJAX，就是典型的异步操作：123456789request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; return success(request.responseText); &#125; else &#123; return fail(request.status); &#125; &#125;&#125; 把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。所以，为了使代码更优雅。出现了这样的写法：123var ajax = ajaxGet('http://...');ajax.ifSuccess(success) .ifFail(fail); 这种链式写法的好处，不单单是优雅。它使得Promise把执行代码和处理结果的代码清晰的分离了。 Promise基础介绍Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 常见用法1234567891011121314var promise = new Promise(function(resolve, reject) &#123; // ... some code if ( /* 异步操作成功 */ ) &#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 再来张图： 看图说话： Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。这两个参数都是函数。 resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。 reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。 then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。 Promise状态因为Promise是用来异步操作的，所以它他有三种状态： Pending （执行中） Fulfilled (已完成) Rejectd （失败）后两者对应着处理结果。 状态间的具体关系： 如上图所示，Promise对象有两个特点：1、对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。2、对象状态一旦改变，任何时候都能得到这个结果。即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。 串行执行通常要串行执行异步任务们，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：1job1.then(job2).then(job3).catch(handleError); 可以这样写的原因是then返回的是promise的实例。这种写法也叫级联。 并行执行除了串行执行若干异步任务外，Promise还可以并行执行异步任务。 试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里2018前端笔试题解答]]></title>
    <url>%2F2017%2F09%2F07%2F%E9%98%BF%E9%87%8C2018%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[序收集整理了大部分的题目，但还是有缺少。希望知道的同学在留言里提供一下题目。 单项选择题单项选择题会给出每题的知识点和答案。答案仅供参考。 下列常见的 HTTP 请求的说法不正确的是的是： 403 状态码表示 Forbidden(资源不能够使用) Expires, Cache-Control，Last-Modified 都是和缓存相关的头。 GET 如果有请求参数，请求参数是在 HTTP 请求行的资源路径上 HTTP 请求中常见的方法包含 GET / POST / UPDATE / DELETE 等 （）错误 GET 请求在客户端中能够被缓存 POST 请求查询字符串(名称/值对)是在 POST 请求的 HTTP 消息主体中发送的 解答： 403 状态码表明对请求资源的访问被服务器拒绝了。 Expire表示实体主体过期时间。Cache-Control控制缓存的行为。Last-Modified ：资源最后一次修改的时间。 HTTP 请求中常见的方法不包含 UPDATE，所以此项错误。 以下对于使用 JavaScript 操作 cookie 的说法正确的是：以下对于使用 JavaScript 操作 cookie 的说法正确的是： 调用 document.cookie = newVal 会清空之前设置的cookie 写入的 cookie 只会存储在本地，不会在每次请求时传递给服务器 cookie 都不会自动失效，需要删除时需要开发者主动删除 在 a.taobao.com 域名下可以写 cookie 到 taobao.com 域名下（正确） cookie 中设置了HttpOnly 的项可以通过 js 读取: HttpOnly 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击. 即使更新一个 cookie 的过期时间为0，也无法删除该 cookie http://jerryzou.com/posts/cookie-and-web-storage/ 不定项选择以下有关 JavaScript 宿主环境的说法正确的有： 在日常开发中用的 JavaScript 类型和函数中，有些是 JavaScript 语言内置的，有些是宿主环境附带的 除了浏览器，Node.js 也能提供一些宿主 API 在某些宿主环境中，JavaScript 可以读写本地文件 如果我们能把 JavaScript 嵌入到其他软件(如 PhotoShop)中，并且提供相应的宿主 API，它也能对那些软件提供的内置功能进行调用。 JavaScript 的宿主对象和内置对象其实是一个概念（错误）： ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，如Math，Global。所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象，如BOM和DOM - 所有的 BOM 和 DOM 对象都是宿主对象以下对于 HTTP/2 的说法正确的是： HTTP/2 支持 Server Push，可以在发送页面 HTML 时主动推送其它资源，如 CSS、JS(true) HTTP/2 支持请求头压缩，而 HTTP/1.1 不支持(true) HTTP/2 支持响应体压缩，而 HTTP/1.1 不支持 生产环境中要使用 HTTP/2 必须部署 HTTPS目前规范中并没有达成一致意见来决定 HTTP/2 是否需要加密 目前并不是所有浏览器都支持 HTTP/2，生产环境仍然不能使用生产环境下，已经可以使用。 HTTP/2 支持多路复用，同域名下所有请求都可以在单个连接上完成。 多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。但是，所有请求都可可以在单个连接上完成？ 以下有关 ES6 的说法不正确的有： 有很多 ES6 的特性已经可以在比较新的浏览器中运行了 ES6 提供的 class 语法，本质上提供了一种比 prototype 的更好的机制（false） 本质上还是使用prototype. 可以通过 Babel 这样的工具，把 ES6 代码转换成能够在更多浏览器中运行的形态 ES6 中的箭头函数(Arrow Function)等同于原先的 function，只是写法进行了简化. let 声明的变量除了支持块级作用域之外跟 var 声明没有什么区别(fasle) let声明的变量拥有块级作用域 let声明的全局变量不是全局对象的属性 形如for (let x…)的循环在每次迭代时都为x创建新的绑定。 let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误。 用let重定义变量会抛出一个语法错误（SyntaxError） ES6 中的模块设计只是把之前社区中形成的 CommonJS 和 AMD 方案纳入到了规范当中(false) 以下关于 Promise 的理解哪些是不正确的： 可以对 Promise 的实例多次调用 then 一般使用 try-catch 的方式捕获 Promise 中产生的错误(false) 在 then 的第一个参数回调里面可以处理 reject 的逻辑，是第二个参数： 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 如果一个函数返回了 Promise 实例，那么就可以对它使用 await 方式来调用 IE11 中还不支持 Promise 如果不设置回调函数，Promise 内部抛出的错误就不会反应到外部问答题请根据面对对象编程的思想，设计一个类型 Cash 用于表达人民币，使得：12345678910 class Cash &#123; &#125; const cash1 = new Cash(105); const cash2 = new Cash(66); const cash3 = cash1.add(cash2); const cash4 = Cash.add(cash1, cash2); const cash5 = new Cash(cash1 + cash2); console.log(`$&#123;cash3&#125;`, `$&#123;cash4&#125;`, `$&#123;cash5&#125;`); 在以上代码执行的时候，输出结果为： 1元7角1分, 1元7角1分, 1元7角1分 12345678910111213141516171819202122232425class Cash &#123; constructor(money) &#123; this.money = money; &#125; static add()&#123; let c = new Cash(); [...arguments].forEach(function(item)&#123; this.money=(this.money||0)+(item.money||0); &#125;.bind(c)); return c; &#125; add()&#123; return Cash.add(this,...arguments); &#125; valueOf() &#123; return this.money; &#125; toString() &#123; return this.money.toString().replace(/(.)(..)$/,"$1元$2").replace(/(.)(.)$/,"$1角$2")+"分"; &#125;&#125; 实现一个EventEmitter类，这个类包含以下方法： on（监听事件，该事件可以被触发多次） once（也是监听事件，但只能被触发一次） fire（触发指定的事件） off（移除指定事件的某个回调方法或者所有回调方法）12345678910111213141516171819202122class EventEmitter &#123; /**请补充你的代码***/&#125;const event = new EventEmitter()const drank = (person) =&gt; &#123; console.log(person + '喝水')&#125;event.on('drank', drank)event.on('eat', (person) =&gt; &#123; console.log(person + '吃东西')&#125;)event.once('buy', (person) =&gt; &#123; console.log(person + '买东西')&#125;)event.fire('drank', '我') // 我喝水 event.fire('drank', '我') // 我喝水 event.fire('eat', '其它人') // 其它人吃东西event.fire('eat', '其它人') // 其它人吃东西event.fire('buy', '其它人') //其它人买东西event.fire('buy', '其它人') //这里不会再次触发buy事件，因为once只能触发一次event.off('eat') //移除eat事件event.fire('eat', '其它人') //这里不会触发eat事件，因为已经移除了 解题思路：这题其实就是实现发布-订阅模式了，难点在于怎样实现once事件，即只触发一次。其实也就是要实现两种类型的事件，我们可以用不同的对象去保存这两种类型的事件，然后在fire的时候，这两种事件都要被处理即可。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class EventEmitter &#123; constructor() &#123; this.queue = &#123;&#125; //可触发多次的事件 this.onceQueue = &#123;&#125; //只能触发一次的事件 &#125; on(event, fn) &#123; //监听事件，可以触发多次 if (!this.queue[event]) this.queue[event] = [] this.queue[event].push(fn) &#125; once(event, fn) &#123; //监听事件，只能触发一次 if (!this.onceQueue[event]) &#123; this.onceQueue[event] = &#123; fns: [], hasFired: false &#125; &#125; this.onceQueue[event].fns.push(fn) &#125; fire() &#123; //触发指定的事件 const event = [].shift.call(arguments), //取得事件名称 fns = this.queue[event], //取得该事件里所有的回调函数（可以触发多次的事件） onceFns = this.onceQueue[event] //取得该事件里所有的回调函数（只能触发一次的事件） if (fns &amp;&amp; fns.length != 0) &#123; let i = 0,fn while (fn = fns[i++]) &#123; fn.apply(this, arguments) &#125; &#125; if (onceFns &amp;&amp; !onceFns.hasFired) &#123; let i = 0,fn while (fn = onceFns.fns[i++]) &#123; fn.apply(this, arguments) &#125; this.onceQueue[event].hasFired = true &#125; &#125; off(event, fn = null) &#123; //可移除特定事件里的某个回调函数或者所有回调函数 const fns = this.queue[event] if (!fns || fns.length == 0) return if (fn) &#123; //移除该事件特定的回调 this.queue[event] = fns.filter(item =&gt; &#123; return item !== fn &#125;) &#125; else &#123; //移除该事件所有的回调 this.queue[event] = [] &#125; &#125;&#125; 此题来源:阿里校招前端笔试题小结]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>求职经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongo Basic]]></title>
    <url>%2F2017%2F09%2F03%2Fmongo_basics%2F</url>
    <content type="text"><![CDATA[MongoDB基本配置下载 MongoDB, 解压后并启动:1$ bin/mongod MongoDB 默认存储数据目录为 /data/db/ (或者 c:\data\db), 当然你也可以修改成不同目录, 只需要指定 –dbpath 参数:1$ bin/mongod --dbpath /path/to/my/data/dir 启动 MongoDB JavaScript 工具来操作数据库:1$ bin/mongo 添加mongo-hacker，更方便的使用mongo1npm install -g mongo-hacker 基本概念 NoSQL意思是“Not Only SQL” NoSQL databases store datain a multitude of formats and are generally less bound to schema controls Mongo does not have a schema, it makes development really fast.Additionally, changing andevolving projects is easy without a schema to migrate. Mongo的查询语句非常简单。实际上，它更像一种编程语言。 The core of Mongo’s data model is documents.Documents are unique records in Mongo, and they are a lot like JSON objects. documents and collection在mongo里，documents是一份个人记录。collection是一张表格，每份documents像是表格上的一行。 因为documents是 individual record，所以严格意义上，他不是关系型数据库上的一行，documents不一定含有所有的列(field)。在关系型数据库中，你必须要先定义好模式（schema），每一列都有特定的类型，而Mongo完全不需要管哪些缺少的值。每个documents的每一个字段都是独立的。 Why ascending or descending indexes matter in Mongo重点在于使用复合键（compound key）的时候，查询方向和key的排序不一致，导致需要跳转索引，是速度变慢。 The db.colleciton.createIndex method documentation: https://docs.mongodb.org/v3.0/reference/method/db.collection.createIndex/#db.collection.createIndex Querying1db.posts.find(&#123;$or:[&#123;title: &quot;I love the holidays&quot;&#125;,&#123;title: &quot;How to workout&quot;&#125;]&#125;,&#123;title: true&#125;); 1Object.keys(db.collection.find()); Mongo’s query operators - https://docs.mongodb.org/v3.0/reference/operator/query/ Map reduce pattern to find all keys in a collection: http://stackoverflow.com/questions/2298870/mongodb-get-names-of-all-keys-in-collection Pagination formula: limit = number of records on each page, skip = number of records on each page * page number - 1 So, with 5 results per page: 1234page 1: limit = 5, skip = 0page 2: limit = 5, skip = 5page 3: limit = 5, skip = 10etc... Updating Data1db.collection.update(&#123;author: ObjectId(&quot;56334t43532csd&quot;)&#125;,&#123;$set: &#123;tags: [&apos;javascript&apos;, &apos;front end&apos;],title: &quot;Update Title&quot;&#125;&#125;) mongo-hacker: https://github.com/TylerBrock/mongo-hacker Mongo’s update modifiers: https://docs.mongodb.org/v3.0/reference/operator/update/ Language Drivers and ShardingMongoDB Drivers: https://docs.mongodb.org/ecosystem/drivers/Sharding in Mongo: https://docs.mongodb.org/manual/sharding/]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《了不起的Node.js》摘记(2)]]></title>
    <url>%2F2017%2F08%2F30%2F%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-js%E3%80%8B%E6%91%98%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[序文章脉络图： TCP中数据传递 HTTP的基础知识和它与TCP的不同 中间件 TCP传输控制协议（TCP）是一个面向连接的协议，它保证了两台计算机之间传输的可靠性和顺序性。 TCP协议对应于TCP/IP体系中的运输层。它向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输 面向连接的通讯和保证顺序的传递通过三次握手建立连接。 通过在IP数据包里添加标志保证顺序的传递 面向字节TCP允许数据以ASCII字符（每个字符一个字节）或者Unicode（每个字符四个字节）进行传递。 正是因为对消息格式没有严格的约束，使得TCP有很好的灵活性。 可靠性数据发送后，发送放等待确认信息。如果过了预定时间，还没收到回信。发送方就会重发。 流控制流控制能确保双方之间传输数据的平衡。避免发送方压垮接收方。 拥堵控制 慢开始 拥塞避免 HTTP超文本传输协议，又称为HTTP，是一种Web协议，它为Web注入很多强大的功能。他是属于TCP上层的协议 HTTP对应于TCP/IP体系中的应用层，主要解决如何包装数据。它能识别数据内容。没有它，传输来的数据就失去意义。 HTTP结构HTTP协议构建在请求和响应的概念上，对应在Node.js中就是http.ServerRequest和http.ServerResponse这两个构造器构造出来的对象。 头信息描述不同的消息内容。 响应文件1234const http = require('http').createServer(function (req, res) &#123; res.writeHead(200,&#123; 'Content-Type': 'image/png'&#125;); require('fs').createReadStream('image.png').pipe(res);&#125;); 连接TCP服务器和HTTP服务器的实现都调用了createServer方法，并且当客户端连入时都会执行一个回调函数。但是，它们之间有本质区别，即回调函数中的对象类型。net 服务器中是个连接（connection）对象，而在HTTp服务器中，则是请求和响应对象。后者比前者更加抽象。后者的内容更丰富，且提供请求和响应的抽象。 使用up重启HTTP服务器 npm install -g up up -watch -port 80 server.js ConnectConnect是一个基于HTTP服务器的工具集，它提供了一种新的组织代码的方式来与请求和响应对象进行交互，即中间件。 Connect能帮你封装网络应用中常见的操作。 中间件中间件能单元化地构建代码，并且能够获得高复用性。 中间件本身只是一个函数，有req，res，next这三个参数：1234567//request_time.jsmodule.exports = function (opts) &#123; return (req, res, next) &#123; //... next(); &#125;;&#125;； 使用中间件：123456789101112var connect = require('connect'), time = require('./request_time');var server = connect.createServer();//记录请求的中间件server.use(connect.logger('dev'));//时间中间件server.use(time(&#123; time: 500&#125;));server.listen(3000); 下面介绍些常用的中间件。 Static中间件挂载static允许将任意一个URL匹配到文件系统中任意一个目录。1server.use('/url',connect.static('/public/images')); maxAgestatic中间件接受一个叫maxAge的选项，这个选项代表一个资源在客户端缓存的时间。1server.use('/js',connect.static('/build/',&#123;maxAge: 10000000&#125;)); hidden托管以 . 开头的隐藏文件：1server.use(connect.static('/res/',&#123;hidden: true&#125;)); Query中间件使用了query，就能获取查询字符串这部分的数据12345server.use(connect.query);// url: /blog-posts?page=5server.use((req, res) =&gt; &#123; //req.query.page&#125;) logger中间件看名字就知道是什么了。 它提供四种日志格式： default dev short tiny1server.use(connect.logger('dev')); body.pares中间件解析POST请求的信息体,还能处理上传的文件。12345server.use(connect.bodyParser());//然乎就可以在req.body中获取信息了server.use((req, res) =&gt; &#123; //req.body.myinput&#125;); cookie和query相似，不过它是用来读写cookie。12345server.use(connect.cookieParser());//然乎就可以在req.cookies中获取信息了server.use((req, res) =&gt; &#123; //req.cookies.secret&#125;); 会话（session）它主要用来记录登录信息，作为多个请求间共享“用户会话”。判断登录信息还要靠req.body和数据库比较。 RedisRedis是一个既小又快的数据库，有一个connect-redis模块使用Redis来持久化session数据。 这样就让session驻扎到了Node进程之外。 具体实现：1234var connect = require('connect'), RedisStore = require('connect-redis')(connect);server.use(connect.session(&#123; store: new RedisStore, secret: 'secret'&#125;));]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《了不起的Node.js》摘记(1)]]></title>
    <url>%2F2017%2F08%2F29%2F%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-js%E3%80%8B%E6%91%98%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[参考链接：Node 中的流（Stream) 序看标题就知道是《了不起的Node.js》的读书笔记。在阅读的过程中会提取自己认为的重点，并简要地概括下它是什么，又怎么用。 书中有涉及不少网络方面的知识。正巧上学期刚上完计算机网络的课，脑袋里还有基本的概念。期末复习时，特地做了一张思维导图。看书的时候时常拿来参考。果然，好记性不如烂笔头，要记笔记，时常做总结。 Stream是Node.js中非常重要的API。但是书中的介绍有点少，而且还比较老。所以，就自己补充了一下。还有书中关于Event Loop的讲解，理解起来让人吃力。推荐大家看一下阮一峰老师的文章。 Javascript概览V8中的javascript获取对象上所用自建键12var obj= &#123; a:'a', b:'b' &#125;;Object.keys(obj);//['a', 'b'] 为函数命名v8能在显示堆栈信息时，将函数名显示出来，如果函数进行命名了话。 PROTO使得定义继承变得更加容易：123function Animal () &#123;&#125;function Ferret() &#123;&#125;Ferret.prototype._proto_ =Animal.prototype; 存取器访问属性使过defineGetter、设置属性使用defineSetter。1Date.prototype.__defineGetter__('name',function()&#123;&#125;); 阻塞与非阻塞IOEvent Loop原书内容不好理解，可以看阮一峰老师的文章。JavaScript 运行机制详解：再谈Event Loop 在基础架构上Node采用一个长期运行的进程。当客户端再次发送请求时，Node的进程不会初始化。所以，作用域的变量会保存修改。 Node通过使用回调函数来创建非阻塞的程序。所以在Node.js的异步编程，要使用回调函数。 Node使用Event Loop。Event Loop就是不断循环Node的主线程，处理非阻塞的程序。在Node的主线程里是不推荐放阻塞程序的。在一次Event Loop时， Event Loop都会查一下callback queue,看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 Node是单线程，所以有些情况下不遵守setTimeout设定的时间。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 错误处理Node对待错误很严格。默认情况下，如果错误没有捕获，进程就会崩溃。 堆栈追踪采用回调函数时，因为无法捕获一个未来才会执行到的函数所抛出的错误，所以，堆栈信息显示的是从事件轮询开始的。这就是为什么在Node.js中，每步都要正确处理的原因。一旦遗漏，错误很难被追踪，因为上下文信息都丢失了。 Node中的JavaScriptglobal全局对象 global: 和浏览器上的window一样。任何global对象上的属性都可以被全局访问。 process: 所用全局执行的上下文内容都在process对象中。实用全局对象console，setTimeout,nextTick(相当于setTimeout(fn,1))模块系统三个核心概念： require module exportsmodule.exports是一个对象。你可以重写它。它决定require获得什么。node通过module.exports来暴露API。 bufferbuffer是一个表示固定内存分配的全局对象。它就好比一个由8位字节元素组成的数组，可以有效地处理二进制数据。 命令行工具常用API fs.readdir(file_path,callback()); fs.readFile(file_path,’utf8’,callback()); fs.stat(file_path, callback()); 文件或目录下的元元素 process.stdin.resume()； 等待输入 process.stdin.setEncoding()； process.stdin.pause(); 暂停流 process.stdin.on(‘event’，callback())； 等待输入 process.stdout.write(); process.argv.slice(2); 获取真正的元素 process.cwd(); 获取当前目录 process.chdir(‘/‘); 灵活地更改目录 process.env变量来轻松访问shell环境下的变量 process.env.NODE_ENV 判断是运行在开发环境下，还是产品模式下。 ANSI转义码为文本添加颜色：1console.log('\033[90m' +data.replace(/(.*)/g,' $1')+'\033[39m'); \033表示转义序列开始 [表示开始颜色设置 90表示前景色是亮灰色 m表示掩饰设置结束 最后用将颜色设置回去 老的Stream当涉及持续不断地对数据进行读写时，流就出现了。 流可以分批处理文件内容：1234var stream = fs.createReadStream(&apos;my-file.txt&apos;);stream.on(&apos;data&apos;, function(chunk)&#123; //deal with files &#125;) 能这样处理文件的原因是,流是循环运行的，不结束就一直存在。这种特性在日志记录时，也很有用。打开文件的操作只要做一次。 以上是老的Stream。Stream 只是一个简单的继承自 EventEmitter 的类。就像上面的文件读取流，一旦开始读取，数据就会源源不断地读出，触发 ‘data’ 事件——嗯一开始的确是一个不错的设计，但如果你想等一下，比如说等待某个回调后再开始处理这些数据。。。好吧，每一片数据只会冒出来一次，没人消费的话它就没了；OK 你想到了用 pause-stream「暂停」一下这个流，等下再消费？完了，数据会暂存在内存中，慢慢堆积，然后，你懂了。 现在的Stream当然并不是说原来不断冒 ‘data’ 的读取方式是不好的，只是说它对于某些情景，比如文件读取，比如网络传输，没办法控制读取速度而已。网络传输注定是没办法控制读取速度的，人家给你多少你都得吃进去；但文件读取，能不能按需要，处理多少读多少呢？ Node 0.10.X 就对 Stream 做了这样的改动：默认情况下，Node 会尽可能使用「拉」模式，也就是说只有 pipe 链末端的流消费者真正需要数据的时候，数据才会从源头被取出，然后顺着管子一路到达消费者。 模拟 HTML POST 表单上传1234567891011121314var request = require('request') , FormStream = require('formstream')var form = FormStream() .field('title', 'ni dong de') .file('attachment', 'hexie.pkg')var upload = request.post('http://xxxx.xxx/upload', &#123; headers: form.headers()&#125;, function (err, res, body) &#123; // ... 略&#125;)form.pipe(upload) Stream 的精髓在于 .pipe() 嗯。 监视fs.watchFile(path,callback()); //文件 fs.watch(path,callback()); //目录]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk中的柯里化]]></title>
    <url>%2F2017%2F08%2F28%2Fredux%E4%B8%AD%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[参考链接： why curry helps Thunkredux中实现异步操作的之一就是使用redux-thunk.redux-thunk中间件改造store.dispatch，使得后者可以接受函数作为参数。它的源码：1234const thunk = (store) =&gt; (next) =&gt; (action) =&gt; typeof action === 'function' ? action(store.dispatch) : next(action); 其实以上就是个柯里化函数，只不过使用了es6的写法。但是看着这么多箭头，我一开始是很懵逼的。不过，只要清楚柯里化就能轻松理解上面的代码。 什么是柯里化函数也是值。从而我们可以用有趣的方法去操作函数。柯里化允许我们把函数与传递给它的值相结合，产生一个新的函数。 换种说法就是把接受多个参数的函数变换成接受一个个单一参数的函数，并且在最后返回（接受余下的参数而且返回结果的）新函数的技术。 柯里化的具体实现对于一个原本需要n个参数的函数，柯里化就是把第一个参数变量存在函数里面，然后返回一个只需要(n-1)个参数的函数。比如：12let add = x =&gt; y =&gt; x + ylet add2 = add(2) 本来完成 add 这个操作，应该是:1let add = (x, y) =&gt; x + y 它需要俩参数，而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数 并且此时 x = 2，所以此时调用1add2(3) === 2 + 3 连续箭头搞清楚里一个箭头，明白n个箭头也不难。n 个连续箭头组成的函数实际上就是柯里化了 n - 1次。 函数里的具体调用过程：前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值。 为什么要用柯里化知道了柯里化的具体实现。你有没有想过，为什么要用它呢？柯里化不就是返回一个部分配置好的函数吗？ 柯里化函数接口123456789101112//beforevar multiple = function(a, b)&#123; return +a*b + ''&#125;var concatArray = function(chars, inc)&#123; return chars.map(function(char)&#123; return multiple(char, inc); &#125;).reduce(function(a,b)&#123; return a.concat(b) &#125;);&#125;console.log(concatArray(['1','2','3'], 2)) 上面的例子的map函数是为了把所有的数字加1，再乘以2。如果我还需要数字都减2呢？是不是又要重新写multiple。是不是很麻烦，那怎么能把他提取出来呢？来对比下柯里化的解法：1234567891011121314151617181920//aftervar multiple = function(a)&#123; return function(b)&#123; return +b*a + '' &#125;&#125;var plus = function(a)&#123; return function(b)&#123; return (+b)+a + '' &#125;&#125;var concatArray = function(chars, stylishChar)&#123; return chars.map(stylishChar) .reduce(function(a,b)&#123; return a.concat(b) &#125;);&#125;console.log(concatArray(['1','2','3'], multiple(2)))console.log(concatArray(['1','2','3'], plus(2))) 有什么不一样呢 处理数组中字符的函数被提取出来, 作为参数传入 提取成柯里化的函数, 部分配置好后传入, 好处显而易见, 这下接口非常通畅 无论是外层调用 1concatArray(['1','2','3'], multiple(2)) 还是内部的 map 函数1chars.map(stylishChar) chars.map(stylishChar)这些接口都清晰了很多, 不是吗 这就是函数式的思想, 用已有的函数组合出新的函数, 而柯里化每消费一个参数, 都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段, 并且使得接口更为流畅. 再加上自动柯里化的库 ramda, 简直就完美了 var multiple = ramda.curry(function(a, b){ return +b*a + ‘’})var plus = ramda.curry(function(a, b){ return (+b)+a + ‘’})1JS Bin&lt;script src="http://static.jsbin.com/js/embed.js"&gt;&lt;/script&gt; 回归正题现在回头看thunk的源码。 它只不过是提前传递了store，供函数形式的action使用。以及next，代表下一个中间件。而最后一个参数’action’像任何其他中间件一样。 不然的话，我们只是把结果传递给链中的下一个中间件而已。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局(-):传统]]></title>
    <url>%2F2017%2F08%2F24%2Fcss%E5%B8%83%E5%B1%80(-)%3A%E7%9B%92%E6%A8%A1%E5%9E%8B-display-float-position%2F</url>
    <content type="text"><![CDATA[参考链接： http://zh.learnlayout.com/ 这个网站真的很棒。实例好，讲解清楚。不急的话，可以直接看他的。 不过我关于浮动和清除的介绍比他详细点，另外还有重置样式表。别忘了回来哦。 传统布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 这篇主要介绍一下传统布局，下篇将Flex。 盒模型每一个元素都会在页面上生成一个盒子。因此，HTML 页面实际上就是由一堆盒子组成的。 在CSS中，使用标准盒模型描述这些矩形盒子中的每一个。这个模型描述了元素所占空间的内容。每个盒子有四个边：外边距边, 边框边, 内填充边 与 内容边。 box-sizing当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。 重置样式表CSS reset的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”！1234567//一般网站的推荐写法body, dl, dd, h1, h2, h3, h4, h5, h6, p ,form &#123; margin:0;&#125;ol,ul &#123; margin:0; padding:0;&#125; 浮动和清除浮动浮动，你看这俩字儿多形象，意思就是把元素从常规文档流中拿出来。 拿出 来干什么?一是可以实现传统出版物上那种文字绕排图片的效果，二是可以让原来 上下堆叠的块级元素，变成左右并列，从而实现布局中的分栏。 当你浮动一个元素的时候……这些(浮动)规则就好像 在说:“尽量把这个元素往上放，能放多高放多高，直到碰到某个元素的边界为止。” clearclear 属性被用于控制浮动。 clear CSS 属性指定一个元素是否可以在它之前的浮动元素旁边，或者必须向下移动(清除浮动) 在它的下面。clear 属性适用于浮动和非浮动元素。 清除浮动浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。父元素会收缩到没它一样。这往往混乱页面的布局。所以我们需要使父元素围住浮动元素。 那怎么办呢？ 通过简单的给父元素加上 class=”clearfix” 做到。123.clearfix &#123; overflow: auto;&#125; 这个可以在现代浏览器上工作。如果你想要支持IE6，你就需要再加入如下样式：1234.clearfix &#123; overflow: auto; zoom: 1;&#125; 没有父元素时，使用clear通过给元素应用clear：both，强迫它定位在前一个浮动元素的下方。 没有父元素，且空间足以容纳多个元素上浮动时，还是使用.clearfix大法。不过这次是给子元素用。 1234567.clearfix:after &#123; content:"."; display:block; height:0; visibility:hidden; clear:both;&#125; 它只添加一个清除的包含句点为非浮动元素。规则中的其他声明只是为了确保这个伪元素没有高度，且不可见。就像有条看不见的分割线，拦住了从下往上冲的元素。 Displaydisplay 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。一个 block 元素通常被叫做块级元素。一个 inline 元素通常被叫做行内元素。 none另一个常用的display值是 none 。一些特殊元素的默认 display 值是它，例如 script 。 display: none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。 它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。 inline-block一种创建网格布局的简单方法。 你得做些额外工作来让IE6和IE7支持 inline-block 。有些时候人们谈到 inline-block 会触发叫做 hasLayout 的东西，你只需要知道那是用来支持旧浏览器的。如果你对此很感兴趣，可以在前面那个链接中找到更详细的信息。否则我们就继续下去吧。 Positionstaticstatic 是默认值。任意 position: static; 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。 relativerelative 表现的和 static 一样，除非你添加了一些额外的属性。 在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。 fixed一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。 absoluteabsolute 是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript语言精粹：对象、函数]]></title>
    <url>%2F2017%2F08%2F20%2FJs%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(2)-%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[对象Javascript的简单数据类型包括数字、字符串、布尔值、null值和undefined值。其他所有的值皆是对象，包括数组、函数和正则表达式。 Javascript中的对象是可变的键控集合。对象是属性的容器，其中属性由键值对构成。 Javascript包含一种原型链的特性，允许对象继承另一个对象。正确的使用它能减少对象初始化时消耗的时间和内存。 ES6中新加入了Class。但这个Class只是简洁了Javascript的语法，让人看上去更清爽。详情见深入浅出ES6（十三）：类 Class 对象字面量一个对象字面量就是包围在一对花括号中的零或多个键值对。对象还是可嵌套的。123456789var flight = &#123; airline_name: "Oceanic", "airline-number": 815, departure: &#123; IATA: "SYD", time: "2017-08-20 13:27", city: "HangZhou" &#125;&#125; 检索属性有两种方式：. 表示法，或object[attr]数组访问法，各有用途。 .表示法用于当要检索的属性为不变常量时，可读性更好，强烈推荐用。 数组访问法在属性为字符串变量时，必用（此时点表示法失效）。 12stooge["first-name"]flight.departure.IATA 引用引用传值都是浅复制。 当你需要某个对象的一份拷贝时，一定要用深复制。 12//对于 JSON 安全的对象(只有由对象和数组组成的对象)，我们的深复制非常简单var newObj = JSON.parse(JSON.stringify(obj)); 当你需要共享某一个对象时，即需要多个变量对同一个对象进行操作，一定要用浅复制 1234_.clone = function(obj) &#123; if (_.isObject(obj)) return obj; return _.isArray(obj) ? obj.slice : _.extend(&#123;&#125;,obj);&#125;; 反射反射用于描述能够检查同一系统（或其自身）中的其他代码的代码。 简单点说。在你不知道一个对象内部结构的情况下(你甚至连这个对象的一个属性，或api都不知道)，怎么跟他通信呢？这个时候就要通过一种机制，得到它的内部结构。这种机制就叫做反射。说白了，窥探对象内部结构的方法就叫做反射。 typeof和hasOwnProperty都是很好的例子。 枚举for infor in 的迭代无序，且包括原型链。虽然可以通过hasOwnProperty()和typeof来过滤. 删除1delete another.name; 函数函数包含一组语句，是js 的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于制定对象的行为。 函数对象除了一般函数，其他所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身. Function构造器产生函数对象，会运行类似这样的代码：123this.prototype = &#123; constructor: this&#125;; Function.prototype的proto指向 Object.prototype, Object.prototype.proto === null .prototype是一个对象的原型对象,而proto则是对原型对象的引用。 Object实际上是一个函数，所以可以Object()。 函数的与众不同之处在于他们可以被调用。 函数字面量123var add = function (a,b) &#123; return x + y ;&#125;; 通过函数字面量创建的函数对象包含一个连到外部上下文连接。这被称为闭包. 调用this的值取决于调用的模式，因为this是延迟绑定的。this到对象的绑定发生在调用时。 方法调用模式this绑定调用方法的对象。1234567var myObject = &#123; value: 0, increment: function (inc) &#123; return this.value += typeof inc === 'number' ? inc : 1; &#125;&#125;;myObject.increment(1); 函数调用模式当一个函数不是对象的属性时，他就是被当作函数来调用。此时this绑定到全局对象.1var sum = add(3,4); 这样直接导致的后果是add方法不能利用内部函数来帮助它工作。因为add的内部函数的this被绑定了错误的值，所以add不能访问对象的属性。 好在可以通过给add方法传入赋值了this的变量，来解决。 解决办法：12345678910myObject.double = function () &#123; var that = this; var helper = function () &#123; that.value = add(that.value,that.value); &#125;; helper();&#125;myObject.double();document.writeln(myObject.value); 构造器调用模式javascript对原型继承不自信的表现。 如果在一个函数前面带上 new 调用，那么背地里将会创建一个新对象。新对象连接到该函数的prototype成员。12345678var Quo = function (string) &#123; this.status = string;&#125;Quo.prototype.get_status = function () &#123; return this.status;&#125;;var myQuo = new Quo('happy');document.writeln(myQuo.get_status()); Apply调用模式javascript是一门函数式的面向对象编程语言，所以函数可以拥有方法。 apply方法帮助我们构建一个参数数组传递给调用函数。它能帮助函数设置this。1234567var statusObject = &#123; status: 'OK'&#125;;//把get_status方法内的作用域换成statusObject的作用域。//即使statusObject没有继承自Quo.prototype,但我们可以在statusObject上调用get_status.var status = Quo.prototype.get_status.apply(statusObject);//status的值为OK。 call()方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 扩充类型功能Javascript允许给语言的基本类型扩充功能。而且给原型扩充时，是动态的。123456Function.prototype.method = function(name, func)&#123; if(!this.prototype[name])&#123;//如果方法已存在，就不添加 this.prototype[name] = func; &#125; return this;&#125;; 递归递归函数就是会直接或间接调用自身的函数。它把一个问题分为一组相似的子问题，每一个都用一个寻常解去解决。 javascript解决汉诺塔问题：1234567var hanoi = function(num，one, two，three)&#123; if(num &gt; 0)&#123; hanoi(num - 1, one, three, two) document.writeln('MOVE num'+num+' from '+one+' to '+ three); hanoi(num-1,three, one, two) &#125;&#125; ##作用域、闭包见我的另一篇文章 回调函数回调函数（callback）是什么？ - 回答作者: no.body 级联返回this的方法，就可以启动级联。 记忆一个函数，它能帮我们构造带记忆功能的函数。1234567891011var memorizer = (memo, formula) =&gt; &#123; var recur = (n) =&gt; &#123; var result = memo[n]; if(typeof result !== 'result') &#123; result = formula(recur, n); memo[n] = result; &#125; return result; &#125; return recur;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript语言精粹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript语言精粹：序、精华与糟粕]]></title>
    <url>%2F2017%2F08%2F19%2Fjs%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(1)-%E7%B2%BE%E5%8D%8E%E4%B8%8E%E7%B3%9F%E7%B2%95%2F</url>
    <content type="text"><![CDATA[序本文是《Javascript语言精粹》的笔记和思考。 为什么要使用Javascript 你没有其他选择。web已变成一个重要的应用开发平台，而javscript是唯一一门所有浏览器都可以识别的语言。 javascript虽然有缺陷，但它真的很优秀。它既轻量又富有表现力。而且，你一旦掌握了它，就会发现函数式编程的魅力。任何语言都有精华和糟粕。我们要取其精华，弃其糟粕。况且，你有权利定义你自己的子集。我们完全可以基于精华部分去编写更好的程序。 Javascript优点 是弱类型语句。 有非常强大的对象字面量表示法。 基于原型继承的动态对象。 函数是顶级对象。函数可以调用方法。Javascript的继承可以借此特性实现。 Javascript缺点以解决办法使用 jshint 或者其他的一些 linter 插件工具来避免自己使用糟糕的特性。 全局变量 javascript依赖全局变量来进行连接。所有编译单元的所有顶级变量被撮合到名为“全局变量”的公共命名空间中。 可以使用es6的let，IIFE等方法解决。 + +的两个运算数只要一个不是 number 类型，+ 就会做字符串拼接。 parseInt(str, int) parseInt(str, int) 遇到非数字会自动停止解析，请一定加上第二个参数来设置进制. 不然假如第一个参数是零开头就会以8进制求值，比如”08”，返回零，因为8进制没有”8” 浮点数0.1 + 0.2 不等于0.310.3 - 0.1 // 0.19999999999999998 使用js库 https://github.com/MikeMcl/decimal.js123x = new Decimal(0.3)x.minus(0.1) // '0.2'x // '0.3' 判断value是不是数字1Number.isFinite('0'); //false 和全局的isFinite()函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。 1234567Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0) // true// 下面这几个如果使用全局的 isNaN() 时，会返回 true。Number.isNaN("NaN"); // false，字符串 "NaN" 不会被隐式转换成数字 NaN。Number.isNaN(undefined); // falseNumber.isNaN(&#123;&#125;); // false 和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。 js没有真正的数组123456typeof [] // 'object'//检测一个值是不是数组function isArray(value) &#123; return Object.prototype.toString.apply(value) === '[object Array]'&#125; null和undefined的区别null表示一个空值对象，即不存在的对象。当声明的变量还未被初始化时，变量的默认值为undefined。null还是一个对象，undefined就表示没有。 null典型用法是： 作为函数的返回值，表示该函数本应该返回对象，但是找不到，即为不存在的对象的意思。 作为对象原型链的终点。 调用函数时，作为缺省的参数。比如1Math.max.apply(null, array); undefined 典型用法是： 变量或对象属性被声明了，但没有赋值时，就等于 undefined。 调用函数时，未传入参数，函数内部该参数等于 undefined。 函数没有返回值时，默认返回 undefined。1Object.getPrototypeOf(Object.prototype); // null 参考链接: js thinking(1):序、精华与糟粕、对象%3A%E5%BA%8F%E3%80%81%E7%B2%BE%E5%8D%8E%E4%B8%8E%E7%B3%9F%E7%B2%95%E3%80%81%E5%AF%B9%E8%B1%A1.md)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript语言精粹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2017%2F08%2F11%2Fwebpack%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[webpack模块化开发webpack本身就是一款用户打包前端模块的工具。主要是用来打包在浏览器端使用的javascript的。同时也能转换、捆绑、打包其他的静态资源，包括css、image、font file、template等 要了解它，首先要知道什么叫模块化开发。 前端开发中，起初只要在script标签中嵌入几十上百行代码就能实现一些基本的交互效果，后来js得到重视，应用也广泛起来了，jQuery，Ajax，Node.Js，MVC，MVVM等的助力也使得前端开发得到重视，也使得前端项目越来越复杂，然而，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块了。但javascript可以实现模块，一个定义了私有变量和函数的函数。 什么鬼，什么叫定义了私有变量和函数的函数？不知道的同学，可以去看一下《javascript语言精粹》的模块章节。 简单地讲，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 这就是模块化开发。而webpack能将依赖的模块转化成可以代表这些包的静态文件。 Webpack它的目标是什么？它和其他类似的工具有什么不同？webpack为什么要将所有资源放在一个文件夹里？详情请见《webpack学习之路》 webpack.config.js详解看代码说话：12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require('webpack');var path = require('path');var config_webpath_dev = require('./configs/webpack_dev');var config = &#123; resolve: &#123; alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125; &#125;, entry: ['./src/index'], output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurenceOrderPlugin() ], module: &#123; loaders: [&#123; test: /\.css$/, loaders: ['style', 'css'] &#125;] &#125;, devServer: &#123; contentBase: "./public", colors: true, historyApiFallback: true, inline: true, hot: true, host: config_webpath_dev.domain, port: config_webpath_dev.port &#125;,&#125;module.exports = config; resolve 这些选项能设置模块如何被解析alias配置项，可以为常用模块配置改属性，可以节省编译的搜索时间。例如：12345resolve:&#123; alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125; &#125; entry 是指入口文件的配置项，它是一个数组的原因是webpack允许多个入口点。output是指输出文件的配置项 path - 表示输出文件的路径 filename - 表示输出文件的文件名 plugins 顾名思义，使用插件可以给webpack添加更多的功能，使webpack更加的灵活和强大,webpack有两种类型的插件:webpack内置的插件12345678910// 首先要先安装webpack模块var webpack = require("webpack");module.exports = &#123; new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;)h&#125;; webpack外置插件1234567//npm install component-webpack-plugin 先要在安装该模版var ComponentPlugin = require("component-webpack-plugin");module.exports = &#123; plugins: [ new ComponentPlugin() ]&#125; 更多的插件以及插件的用法，大家可以到webpack的插件上查看。 module 决定了如何处理项目中的不同类型的模块。它通过配置要使用的loader，把资源文件（css、图片、html等非js模块）处理成相应的js模块,然后其它的plugins才能对这些资源进行下一步处理。比如babel-loader可以把es6的文件转换成es5。loaders 一个含有wepback中能处理不同文件的加载器的数组 test 用来匹配相对应文件的正则表达式 loaders 告诉webpack要利用哪种加载器来处理test所匹配的文件loaders 的安装方法1$ npm install xxx-loader --save-dev devServer(webpack-dev-server) 能够用于快速开发应用程序 color - Enables/Disables colors on the console. contentBase - 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。 historyApiFallback - 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html. hot - 启用 webpack 的模块热替换特性. inline - 默认情况下，应用程序启用内联模式(inline mode)。这意味着一段处理实时重载的脚本被插入到你的包(bundle)中，并且构建消息将会出现在浏览器控制台。 host - 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问，指定如下： port - 指定要监听请求的端口号]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML和CSS杂记]]></title>
    <url>%2F2017%2F08%2F09%2Fcss%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[CSS要点《css设计指南》笔记 HTMLsection只有元素内容会被列在 文档大纲 中时，才适合用section元素。 这里的文档大纲更像是提纲，section 就是提纲中的不重复项（比如对于博文 list，整个 list 才属于一个 section） 块级元素和行内元素块级元素盒子会扩展到与父元素同宽 明确设定 width 属性后，块级元素就不会再扩展到与父元素(即 body)同宽了。没有设定 width，值为 auto。行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。 CSS伪类伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。 UI伪类会在 HTML 元素处于某个状态时(比如鼠标 指针位于链接上)，为该元素应用 CSS 样式。 结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第一个或最后一个)，为相应元素应用 CSS 样式。UI伪类 链接伪类(link 未被点，visited 已被点，hover 鼠标悬停，active 正在被点) :focus 伪类 表单中的文本字段在用户单击它时会获得焦点，获得焦点时使用 css 样式。 :target 伪类，用户点击一个指向页面中其他元素的链接。常用于页面内跳转里，来显示跳转到的位置，使用举例1&lt;a href="#more_info"&gt;More Information&lt;/a&gt; 位于页面其他地方、ID 为 more_info 的那个元素就是目标。该元素可能是这样的:1&lt;h2 id="more_info"&gt;This is the information you are looking for.&lt;/h2&gt; 那么，如下 CSS 规则1#more_info:target &#123;background:#eee;&#125; 会在用户单击链接转向 ID 为 more_info 的元素时，为该元素添加浅灰色背景。 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。 ::first-letter 伪元素 :1p::first-letter &#123;font-size:300%;&#125; 可以得到段落首字符放大的效果。 ::first-line 伪元素 ::before 和::after 伪元素 :12p.age::before &#123;content:"Age: ";&#125;p.age::after &#123;content:" years.";&#125; 伪类与伪元素的区别伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 权重浏览器通过权重来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。 权重是如何计算的？优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。 而当优先级与多个CSS声明中任意一个声明的优先级相等的时候，CSS中最后的那个声明将会被应用到元素上。 当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的CSS规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。 MORE 背景 background-color background-image background-repeat background-position background-size background-attachment background(简写属性) 背景图片123p &#123; background-image:url(images/turq_spiral.png);&#125; 背景重复repeat(默认),repeat-x,repeat-y,no-repeat. 背景位置123p#center &#123; background-position:center;//top,left,bottom,right&#125; 多背景图片12345p &#123; background: url(images/turq_spiral.png) 30px -10px no-repeat, url(images/pink_spiral.png) 145px 0px no-repeat, url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75; &#125; 背景渐变线性渐变12345678.gradient1 &#123;background:linear-gradient(#e86a43, #fff);//从上到下&#125;.gradient3 &#123; background:linear-gradient(-45deg, #e86a43, #fff);//从左上到右下&#125; .gradient2 &#123; 1 background:linear-gradient(left, #64d1dd, #fff);&#125; 渐变点12345678.gradient1 &#123; background:linear-gradient(#e86a43 20%, #fff 50%, #e86a43 80%); &#125;.gradient3 &#123; background:linear-gradient(#64d1dd, #fff 25%, #64d1dd 50%, #fff 75%, #64d1dd);&#125;.gradient4 &#123;background:linear-gradient(#e86a43, #fff 25%, #64d1dd 25%, #64d1dd 75%, #fff 75%, #e86a43);&#125; 放射性渐变123456789.gradient1 &#123;background: -webkit-radial-gradient(#fff, #64d1dd, #70aa25); &#125;.gradient2 &#123; background: -webkit-radial-gradient(circle, #fff, #64d1dd, #e86a43); &#125;.gradient3 &#123; background: -webkit-radial-gradient(50px 30px, circle, #fff, #64d1dd,#4947ba); &#125; 字体和文本字体族1body &#123;font-family: "Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;&#125; 在指定文本的字体时，需要多列出几种后备字体， 以防第一种字体无效。这个字体的列表也叫字体栈。 字体类 serif，也就是衬线字体 sans-serif，也就是无衬线字体 monospace，也就是等宽字体 cursive，也就是草书体或手写体 fantasy，不能归入其他类别的字体(一般都是奇形怪状的字体)。使用这些通用字体类的目的，就是确保在最坏的情况下，文档起码可以通过正确的字形来显示，将通用字体类写到最后即可。 字体样式值:italic、oblique、normal。 示例:h2 {font-style:italic;} 。 文本属性 文本缩进: text-indent 字符间距: letter-spacing 单词间距: word-spacing 文本对齐: text-align，值:left、right、center、justify。 行高: line-height 文本装饰: text-decoration，值:underline、overline、line-through、none。 表单12&lt;form class='style_form' action='process_form.php' method='post'&gt;&lt;/form&gt; action 用于指定服务器上用来处理表单数据的文件的URL。 method (值要么是post，要么是get)用于指定怎么把数据发送到服务器上。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的重要性]]></title>
    <url>%2F2017%2F07%2F23%2FCSS%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS玉伯看HTML和CSS代码的背后https://github.com/lifesinger/blog/issues/105&gt; 之前在freeCodeCamp上看到两篇置顶的前端入门文章。第一篇的内容涉及html和css。第二篇就讲javascritpt。看第一篇内容时，真是被文章丰富的内容吓了一跳。当时心里就嘀咕，真的要学这么多吗？ 直到今天看了玉伯的文章，才意识到html和css同样非常重要。所以，特地做一下笔记，把所思所想理一下。 让块元素水平居中。一般大家都会写成：1234.content &#123; width: 980px; margin: 0 auto;&#125; 上面的代码能正常工作，大部分情况下也不会有问题，但上面的代码存在思维的懒惰。应该写成:12345.content &#123; width: 980px; margin-left: auto; margin-right: auto;&#125; 看起来代码变多了，变啰嗦了。但如果你真的了解 margin: 0 auto 的话，就能明白其中的意义。 margin: 0 auto 的实现：123456&#123; margin-top:0; margin-bottom:0; margin-left:auto; margin-right:auto;&#125; 可以看到 margin: 0 auto 中会帮你把top和bottom重置了。可是，你只想要“水平居中”而已。 这种不纯粹会导致顺序和优先级的依赖，比如有另一处要给 margin-top/bottom 赋值时，就必须要提高优先级。 而且 margin: 0 auto 中的 0 绝大部分情况下是冗余的，页面上早就有 reset.css 或 normalize.css 重置过。 最小影响原则你在写某段CSS代码时，首先要非常清楚地知道这段CSS代码的功能，其次要尽量严格保障这段CSS代码只实现了你想要实现的功能。 这就如医生动手术，好好做好本分就行，千万别留下一个小镊子在病人身体里。 与HTML代码一样，对CSS代码来说，很重要的两个衡量标准也是稳定和灵活。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js基础：作用域、闭包、this]]></title>
    <url>%2F2017%2F07%2F22%2FJs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81this%2F</url>
    <content type="text"><![CDATA[作用域词法作用域：描述了源代码中的范围。 if语句或while语句以及其他类似循环结构的语句块不能创建新的作用域。只用function语句块能创建新的作用域。 执行环境：当程序运行的时候，会创建一个存储变量和变量值的存储系统。这些内存中的作用域结构被称为执行环境。 执行环境和词法作用域的不同：执行环境实在程序运行时才被创建的，不是在代码输入时被创建的。执行环境能控制在程序执行过程中不同点能访问哪些变量。注：12345var test=function()&#123;&#125;;var test1=test();var test2=test();log(test1===test2);//falsejavascript不对对象进行引用 闭包闭包是指一些函数通过某种方式可以随时被访问，即使它的外部代码已经执行完毕。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 常见的闭包的现象，如通过函数字面量创建的函数对象包含一个连到外部上下文的连接。123var hello = function (a，b) &#123; return a + b；&#125; 保留函数访问权限的方法 passing to setTimeout 从函数中return 123456789function f1()&#123; var n=999;//只要内部函数需要，n会持续保留 function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 保存为全局变量 一个重要的问题javascript的内部函数访问外部函数的实际变量而无须复制。这个特性，常常会引发一类错误：1234567var add_the_handlere = (nodes) =&gt; &#123; for (var i = 0; i&lt; nodes.length; i++)&#123; nodes[i].onclick = (e) =&gt; &#123; alert(i); &#125;; &#125;&#125;; 因为内部函数访问外部函数的实际变量而无须复制，所以“alert(i)”中的i绑定的是外部i本身，而不是函数构造时的变量值。这就导致每个事件处理器的i都相同。 用处 设计模块中的私有属性和方法（闭包中的自由变量无法被直接访问） 让这些变量的值始终保持在内存中(可以被延迟调用，比如事件 handler，ajax 异步调用的回调函数等)。 Thisthis指调用函数的那个对象 使用new的时候会发生什么 创建一个新的空对象；//Object.create(); 将this绑定到该对象； 添加一个名为proto的新属性，并且指向构造函数的原型(prototype)； 返回该this对象。//return this; this的用法 纯粹的函数调用: this 就代表全局对象 Global（浏览器下就是 window）。 作为对象方法的调用: this 指向调用方法的对象。 作为构造函数调用：this 就指向 构造器创建的新对象 apply, call, bind调用：this 指向就是这些函数的第一个参数 原型链当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止（这种行为我们也称之为委托）。 原型链是使用其他对象属性的一种方式。 原型链的属性复制发生在当前查找的时候，所以是实时更新的。 推荐阮一峰老师的这篇文章：Javascript为什么会有prototype]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js基础：Array、String的常用方法]]></title>
    <url>%2F2017%2F07%2F22%2FJs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%9AArray%E3%80%81String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Array ECMAScript数组的大小是可以动态调整的，既可以随着数据的添加自动增长以容纳新增数据。当把一个值放在超出当前数组大小的位置上时，数组就会重新计算长度值，即长度值等于最后一项的索引加一，前面的值都自动被赋值为了undefined了。 Array.prototype.concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。123var one=['a','b'];var two=['d','c'];var three=one.concat(two);//three[a,b,c,d] one[a,b] two[c,d] 描述 concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里. 简单的说 concat不修改原数组 concat是浅复制，只是对于数组包含的元素的复制。 队列、堆栈Array.prototype.shift()shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 Array.prototype.unshift()The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array. Array.prototype.push()The push() method adds one or more elements to the end of an array and returns the new length of the array. Array.prototype.pop()The pop() method removes the last element from an array and returns that element. This method changes the length of the array. Array.join(separator)数组格式化输出，返回字符串。以 separator 分隔，separator 默认为’,’1[1,2,3].join(' ') // '1 2 3' Array.prototype.slice(begin,end)返回数组中的一部分的浅复制到一个新的数组对象，只对数组中的元素进行浅复制。原始数组不会被修改。12345var a = ['zero', 'one', 'two', 'three'];var sliced = a.slice(1, 3);console.log(a); // ['zero', 'one', 'two', 'three']console.log(sliced); // ['one', 'two'] Array.prototype.splice(start, deleteCount, items…)splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 高阶函数Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 Array.prototype.reduce()reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array)&#123; return accumulator + currentValue;&#125;);// 10 描述reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： accumulator 初始值（或者上一次回调函数的返回值） currentValue 当前元素值 currentIndex 当前索引 array 调用 reduce 的数组。 回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 callback 函数会被自动传入三个参数：当前数组元素，当前元素索引，原数组本身 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] Array.prototype.filter()The filter() method creates a new array with all elements that pass the test implemented by the provided function. 1234567var words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];var longWords = words.filter(function(word)&#123; return word.length &gt; 6;&#125;)// Filtered array longWords is ["exuberant", "destruction", "present"] [数组的其他方法和属性]（https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array）Stringstring.charAt(pos)返回只含一个字母的字符串 string.indexOf(searchString, position)返回字符串里面的字母所在的位置下标，实际上把 string 看成一个 char[]，更容易理解 string.slice(start, end)返回子字符串，参数可以为负数 string.match(regexp)返回比配字符串，假如有正则表达式为/xxx/g则，返回一个数组，否则返回第一次匹配到的字符串 string.replace(searchValue, replaceValue)替换字符串，searchValue 可以为正则表达式。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人工智能狂潮》摘记]]></title>
    <url>%2F2017%2F05%2F23%2F%E3%80%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8B%82%E6%BD%AE%E3%80%8B%E6%91%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是人工智能？专家观点：尚未统一。作者的定义是，人工智能是“用人工方法制作的类人智能”，类人智能指的是具有“发现和觉察功能”的计算机，即能够从数据中生成特征量，并对相关现象进行模型化处理的计算机。 人工智能的发展历史人工智能的研究是从以“推理”为重点到以“知识”为重点，再到以“学习”为重点，一条自然、清晰的脉络。 第一次人工智能狂潮的局限（20世纪60年代）计算机只能解决所谓的“玩具问题”。求解迷宫问题，挑战国际象棋及将棋，这些都只需要在明确定义好的规则中考虑下一步如何走起即可，然而，现实生活中的问题却要复杂得多。 第二次人工智能狂潮的局限（20世纪80年代末）永无穷尽的知识Example: He saw a woman in the garden with a telescope. 理解这句话，需要一般性的常识。而计算机要处理一般性的常识，就需要掌握人类所拥有的，永运也无法写尽的海量知识，这是极其困难的。因为，同样的事情在所有的各种各样的场合皆会发生。 它用望眼镜看到一个女人在花园呢？还是他在公园用望眼镜看到一个女人？ 框架问题框架问题，就是执行某项任务时“仅仅提取出与它相关的知识并对其加以运用”，这对人类来说简单的事，但对计算机来说是困难无比的。 认识框架问题 符号接地问题是否能将符号（词语,语言）与它所表示的意义连接起来。 日本在1982年启动了名为“第五代计算机”的国家级项目，从1982年开始前后跨越了10年，总共投入了570亿日元。尽管没有实现预定目标，但是它聚集了人工智能研究的优秀人才，还吸引了众多的海外知名专家，并由此建立了相关的人才联系网络。 第三次人工智能狂潮（机器学习，深度学习）机器学习机器学习，一种实现人工智能的方法。 它是使用算法来分析数据的实践、学习，然后对真实的事件作出决定或预测。而不是用一组特定的指令生成的硬编码软件程序来解决特定任务。机器是通过使用大量的数据和算法来「训练」，这样就给了它学习如何执行任务的能力。 机器学习的难点机器学习最关键的地方是如何把一个把原始数据转变成特征量。这些特征量可以很好的描述这些数据，并且利用它们建立的模型在未知数据上的表现性能可以达到最优（或者接近最佳性能）。从数学的角度来看，特征工程就是人工地去设计输入变量X。 可惜的是特征量的设计必须由人来做。 特征量，指的是机器学习在输入时所使用的变量，其值是对对象特征的定量表示。 深度学习wiki上的解释： 深度学习（英语：deep learning）是机器学习拉出的分支，它试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。 深度学习， 一种实现机器学习的技术。它能自己产生特征量。其实回过头看，人工智能的发展其实是给予机器越来越抽象的基本信息。 至于深度学习的实现过程，我其实也是模模糊糊。等有深入了解后，再来改进这篇文章。]]></content>
      <categories>
        <category>编程之外</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读Android原生计算器源码]]></title>
    <url>%2F2017%2F05%2F17%2F%E9%98%85%E8%AF%BBAndroid%E5%8E%9F%E7%94%9F%E8%AE%A1%E7%AE%97%E5%99%A8%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Read Android Original Calculator项目结构 Calculator CalculatorPadLayout CalculatorNumericPadLayout CalculatorPadViewPager CalculatorExpressionBuilder CalculatorExpressionEvaluator CalculatorExpressionTokenizer CalculatoronBackPressed()处在第高级操作符页面时，点击back键，返回初始页面。 onUserInteraction()Called whenever a key, touch, or trackball event is dispatched to the activity. 在处理用户交互前，如果由正在进行的动画请立即终止。 onEquals()至于计算，只要获得式子的字符串，然后交给 org.javia.arity.Symbol就行了。12//一句话的事double result = mSymbols.eval(expr); CalculatorPadViewPager为什么在显示page1的时候page2会显示出来一部分呢（右侧青色那一条）？答案在setPageMargin(-24);由于是负数，这样每个page之间就会有重叠，就出现了明明显示的第一个view，结果在右侧显示了一部分第二个view的layout。 为什么向左滑动的时候page1的位置一直保持不动？不应该是向左侧滑出吗？看setPageTransformer(false, mPageTransformer); 123456789/*** Apply a property transformation to the given page.** @param page Apply the transformation to this page* @param position Position of page relative to the current front-and-center* position of the pager. 0 is front and center. 1 is one full* page position to the right, and -1 is one page position to the left.*/public void transformPage(View page, float position); 看一下源码里的方法说明，这里的position其实是相对的，并不是常规理解的位置下标，它是以当前屏幕的正中心为坐标原点，当page的中心和屏幕的原点重合（即page正在完全显示时）position=0;当page向左侧滑动，慢慢淡出屏幕时，该过程中page的中心相对屏幕的中心原点在沿着X轴向左移动，此时positon &lt; 0，当page完全滑出屏幕时，positon = -1;同理，当page向右滑动，慢慢淡出屏幕时，该过程中page的中心相对屏幕的中心原点在沿着X轴向右移动，此时positon &gt; 0，当page完全滑出屏幕时，positon = 1； 有了上面的分析，其实可以把positon看成正在滑动的page滑出屏幕的比例，正负代表往哪个方向滑动。所以，要想在滑出数学计算公式的page过程中保持当前输入的page位置不动，根据滑出屏幕的比例设置该page在X轴的偏移量就可以了，view.setTranslationX(getWidth() * -position); 同理，把数学计算公式的page滑出时取消这个偏移量，view.setTranslationX(0); 到这里疑问2也解决了。 更多的ViewPager切换动画请参考开源项目JazzyViewPager 还有就是当page2滑出后宽度为什么没有铺满、左边还要留出一部分透明区域呢？原来是复写了PagerAdapter的getPageWidth方法，看一下该方法的说明： 12345678910/** * Returns the proportional width of a given page as a percentage of the * ViewPager's measured width from (0.f-1.f] * * @param position The position of the page requested * @return Proportional width for the given page position */public float getPageWidth(int position) &#123; return 1.f;&#125; 说的很清晰了，根据position设置当前页面宽度的百分比。 123public float getPageWidth(int position) &#123; return position == 1 ? 7.0f / 9.0f : 1.0f; &#125; OnPageChangeListener解读Callback interface for responding to changing state of the selected page. OnPageChangeListener这个接口需要实现三个方法：（onPageScrollStateChanged，onPageScrolled ，onPageSelected）：onPageScrollStateChanged(int arg0) ，此方法是在状态改变的时候调用，其中arg0这个参数。有三种状态（0，1，2）。arg0 ==1的时辰默示正在滑动，arg0==2的时辰默示滑动完毕了，arg0==0的时辰默示什么都没做。 onPageScrolled(int arg0,float arg1,int arg2) ，当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为： arg0 :当前页面，及你点击滑动的页面 arg1:当前页面偏移的百分比 arg2:当前页面偏移的像素位置 onPageSelected(int arg0) ： 此方法是页面跳转完后得到调用，arg0是你当前选中的页面的Position（位置编号）。 CalculatorPadLayout自定义了数字键盘的布局。规定了每个按键的长宽高，以及位置。 CalculatorNumericPadLayout extends CalculatorPadLayout根据id设置按钮属性。 总结原本不知道怎么实现的效果，发现方法其实很简单。当然，你得对源码很了解，才能想到。 小要点SpannableStringBuilderThis is the class for text whose content and markup can both be changed TextWatchWhen an object of a type is attached to an Editable, its methods will be called when the text is changed.]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Contentprovider]]></title>
    <url>%2F2017%2F04%2F28%2F%E7%90%86%E8%A7%A3Contentprovider%2F</url>
    <content type="text"><![CDATA[How to use content providerwhat is a content provider?content provider是位于应用和其数据源之间地类。它能让应用轻松地访问相关数据源，并且访问过程得到管理。 why is it useful? 作为额外地抽象化操作，它允许开发者更改相关数据源，而不用更改访问内容提供器地应用中地代码。 SyncAdapters，Loaders，CursorAdapter需要通过contetn provider 访问数据。 向其他应用开发数据源，使他们能够访问，使用修改你的数据源。 用途： 提取基础数据，安全高效地跨应用边界分享数据 轻松地切换数据源，而且更便于他人管理UI层代码 向小部件发送数据，或从更新的应用返回搜索结果 有效地与服务器同步，并在UI层实时更新 ContentResolverContentResolver使应用与正确的ContentProvider沟通。 Cursorcursor是一种迭代器，使程序能够以表格的形式访问相关数据。 SimpleExample：12345678910111213141516171819// Get the TextView which will be populated with the Dictionary ContentProvider data. ListView dictListView = (ListView) findViewById(R.id.dictionary_list_view); // Get the ContentResolver which will send a message to the ContentProvider. ContentResolver resolver = getContentResolver(); // Get a Cursor containing all of the rows in the Words table. Cursor cursor = resolver.query(UserDictionary.Words.CONTENT_URI, null, null, null, null); // Set the Adapter to fill the standard two_line_list_item layout with data from the Cursor. SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.two_line_list_item, cursor, COLUMNS_TO_BE_BOUND, LAYOUT_ITEMS_TO_FILL, 0); // Attach the adapter to the ListView. dictListView.setAdapter(adapter);]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
