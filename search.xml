<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里2018前端面试题解答]]></title>
    <url>%2F2017%2F09%2F07%2F%E9%98%BF%E9%87%8C2018%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[阿里巴巴2018校招前端笔试题 单项选择题单项选择题会给出每题的知识点和答案。答案仅供参考。 下列常见的 HTTP 请求的说法不正确的是的是： 403 状态码表示 Forbidden(资源不能够使用) Expires, Cache-Control，Last-Modified 都是和缓存相关的头。 GET 如果有请求参数，请求参数是在 HTTP 请求行的资源路径上 HTTP 请求中常见的方法包含 GET / POST / UPDATE / DELETE 等 （）错误 GET 请求在客户端中能够被缓存 POST 请求查询字符串(名称/值对)是在 POST 请求的 HTTP 消息主体中发送的 解答： 403 状态码表明对请求资源的访问被服务器拒绝了。 Expire表示实体主体过期时间。Cache-Control控制缓存的行为。Last-Modified ：资源最后一次修改的时间。 HTTP 请求中常见的方法不包含 UPDATE，所以此项错误。 以下对于使用 JavaScript 操作 cookie 的说法正确的是：以下对于使用 JavaScript 操作 cookie 的说法正确的是： 调用 document.cookie = newVal 会清空之前设置的cookie 写入的 cookie 只会存储在本地，不会在每次请求时传递给服务器 cookie 都不会自动失效，需要删除时需要开发者主动删除 在 a.taobao.com 域名下可以写 cookie 到 taobao.com 域名下（正确） cookie 中设置了HttpOnly 的项可以通过 js 读取: HttpOnly 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击. 即使更新一个 cookie 的过期时间为0，也无法删除该 cookie http://jerryzou.com/posts/cookie-and-web-storage/ 不定项选择以下有关 JavaScript 宿主环境的说法正确的有： 在日常开发中用的 JavaScript 类型和函数中，有些是 JavaScript 语言内置的，有些是宿主环境附带的 除了浏览器，Node.js 也能提供一些宿主 API 在某些宿主环境中，JavaScript 可以读写本地文件 如果我们能把 JavaScript 嵌入到其他软件(如 PhotoShop)中，并且提供相应的宿主 API，它也能对那些软件提供的内置功能进行调用。 JavaScript 的宿主对象和内置对象其实是一个概念（错误）： ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，如Math，Global。所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象，如BOM和DOM - 所有的 BOM 和 DOM 对象都是宿主对象以下对于 HTTP/2 的说法正确的是： HTTP/2 支持 Server Push，可以在发送页面 HTML 时主动推送其它资源，如 CSS、JS(true) HTTP/2 支持请求头压缩，而 HTTP/1.1 不支持(true) HTTP/2 支持响应体压缩，而 HTTP/1.1 不支持 生产环境中要使用 HTTP/2 必须部署 HTTPS目前规范中并没有达成一致意见来决定 HTTP/2 是否需要加密 目前并不是所有浏览器都支持 HTTP/2，生产环境仍然不能使用生产环境下，已经可以使用。 HTTP/2 支持多路复用，同域名下所有请求都可以在单个连接上完成。 多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。但是，所有请求都可可以在单个连接上完成？ 以下有关 ES6 的说法不正确的有： 有很多 ES6 的特性已经可以在比较新的浏览器中运行了 ES6 提供的 class 语法，本质上提供了一种比 prototype 的更好的机制（false） 本质上还是使用prototype. 可以通过 Babel 这样的工具，把 ES6 代码转换成能够在更多浏览器中运行的形态 ES6 中的箭头函数(Arrow Function)等同于原先的 function，只是写法进行了简化. let 声明的变量除了支持块级作用域之外跟 var 声明没有什么区别(fasle) let声明的变量拥有块级作用域 let声明的全局变量不是全局对象的属性 形如for (let x…)的循环在每次迭代时都为x创建新的绑定。 let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误。 用let重定义变量会抛出一个语法错误（SyntaxError） ES6 中的模块设计只是把之前社区中形成的 CommonJS 和 AMD 方案纳入到了规范当中(false) 以下关于 Promise 的理解哪些是不正确的： 可以对 Promise 的实例多次调用 then 一般使用 try-catch 的方式捕获 Promise 中产生的错误(false) 在 then 的第一个参数回调里面可以处理 reject 的逻辑，是第二个参数： 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 如果一个函数返回了 Promise 实例，那么就可以对它使用 await 方式来调用 IE11 中还不支持 Promise 如果不设置回调函数，Promise 内部抛出的错误就不会反应到外部问答题请根据面对对象编程的思想，设计一个类型 Cash 用于表达人民币，使得：12345678910 class Cash &#123; &#125; const cash1 = new Cash(105); const cash2 = new Cash(66); const cash3 = cash1.add(cash2); const cash4 = Cash.add(cash1, cash2); const cash5 = new Cash(cash1 + cash2); console.log(`$&#123;cash3&#125;`, `$&#123;cash4&#125;`, `$&#123;cash5&#125;`); 在以上代码执行的时候，输出结果为： 1元7角1分, 1元7角1分, 1元7角1分 12345678910111213141516171819202122232425class Cash &#123; constructor(nc) &#123; this.nc = nc; &#125; static add()&#123; let c = new Cash(); [...arguments].forEach(function(item)&#123; this.money=(this.money||0)+(item.money||0); &#125;.bind(c)); return c; &#125; add()&#123; return Cash.add(this,...arguments); &#125; valueOf() &#123; return this.nc; &#125; toString() &#123; return this.nc.toString().replace(/(.)(..)$/,"$1元$2").replace(/(.)(.)$/,"$1角$2")+"分"; &#125;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>求职经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongo Basic]]></title>
    <url>%2F2017%2F09%2F03%2Fmongo_basics%2F</url>
    <content type="text"><![CDATA[MongoDB基本配置下载 MongoDB, 解压后并启动:1$ bin/mongod MongoDB 默认存储数据目录为 /data/db/ (或者 c:\data\db), 当然你也可以修改成不同目录, 只需要指定 –dbpath 参数:1$ bin/mongod --dbpath /path/to/my/data/dir 启动 MongoDB JavaScript 工具来操作数据库:1$ bin/mongo 添加mongo-hacker，更方便的使用mongo1npm install -g mongo-hacker 基本概念 NoSQL意思是“Not Only SQL” NoSQL databases store datain a multitude of formats and are generally less bound to schema controls Mongo does not have a schema, it makes development really fast.Additionally, changing andevolving projects is easy without a schema to migrate. Mongo的查询语句非常简单。实际上，它更像一种编程语言。 The core of Mongo’s data model is documents.Documents are unique records in Mongo, and they are a lot like JSON objects. documents and collection在mongo里，documents是一份个人记录。collection是一张表格，每份documents像是表格上的一行。 因为documents是 individual record，所以严格意义上，他不是关系型数据库上的一行，documents不一定含有所有的列(field)。在关系型数据库中，你必须要先定义好模式（schema），每一列都有特定的类型，而Mongo完全不需要管哪些缺少的值。每个documents的每一个字段都是独立的。 Why ascending or descending indexes matter in Mongo重点在于使用复合键（compound key）的时候，查询方向和key的排序不一致，导致需要跳转索引，是速度变慢。 The db.colleciton.createIndex method documentation: https://docs.mongodb.org/v3.0/reference/method/db.collection.createIndex/#db.collection.createIndex Querying1db.posts.find(&#123;$or:[&#123;title: &quot;I love the holidays&quot;&#125;,&#123;title: &quot;How to workout&quot;&#125;]&#125;,&#123;title: true&#125;); 1Object.keys(db.collection.find()); Mongo’s query operators - https://docs.mongodb.org/v3.0/reference/operator/query/ Map reduce pattern to find all keys in a collection: http://stackoverflow.com/questions/2298870/mongodb-get-names-of-all-keys-in-collection Pagination formula: limit = number of records on each page, skip = number of records on each page * page number - 1 So, with 5 results per page: 1234page 1: limit = 5, skip = 0page 2: limit = 5, skip = 5page 3: limit = 5, skip = 10etc... Updating Data1db.collection.update(&#123;author: ObjectId(&quot;56334t43532csd&quot;)&#125;,&#123;$set: &#123;tags: [&apos;javascript&apos;, &apos;front end&apos;],title: &quot;Update Title&quot;&#125;&#125;) mongo-hacker: https://github.com/TylerBrock/mongo-hacker Mongo’s update modifiers: https://docs.mongodb.org/v3.0/reference/operator/update/ Language Drivers and ShardingMongoDB Drivers: https://docs.mongodb.org/ecosystem/drivers/Sharding in Mongo: https://docs.mongodb.org/manual/sharding/]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《了不起的Node.js》摘记(2)]]></title>
    <url>%2F2017%2F08%2F30%2F%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-js%E3%80%8B%E6%91%98%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[序文章脉络图： TCP中数据传递 HTTP的基础知识和它与TCP的不同 中间件 TCP传输控制协议（TCP）是一个面向连接的协议，它保证了两台计算机之间传输的可靠性和顺序性。 TCP协议对应于TCP/IP体系中的运输层。它向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输 面向连接的通讯和保证顺序的传递通过三次握手建立连接。 通过在IP数据包里添加标志保证顺序的传递 面向字节TCP允许数据以ASCII字符（每个字符一个字节）或者Unicode（每个字符四个字节）进行传递。 正是因为对消息格式没有严格的约束，使得TCP有很好的灵活性。 可靠性数据发送后，发送放等待确认信息。如果过了预定时间，还没收到回信。发送方就会重发。 流控制流控制能确保双方之间传输数据的平衡。避免发送方压垮接收方。 拥堵控制 慢开始 拥塞避免 HTTP超文本传输协议，又称为HTTP，是一种Web协议，它为Web注入很多强大的功能。他是属于TCP上层的协议 HTTP对应于TCP/IP体系中的应用层，主要解决如何包装数据。它能识别数据内容。没有它，传输来的数据就失去意义。 HTTP结构HTTP协议构建在请求和响应的概念上，对应在Node.js中就是http.ServerRequest和http.ServerResponse这两个构造器构造出来的对象。 头信息描述不同的消息内容。 响应文件1234const http = require('http').createServer(function (req, res) &#123; res.writeHead(200,&#123; 'Content-Type': 'image/png'&#125;); require('fs').createReadStream('image.png').pipe(res);&#125;); 连接TCP服务器和HTTP服务器的实现都调用了createServer方法，并且当客户端连入时都会执行一个回调函数。但是，它们之间有本质区别，即回调函数中的对象类型。net 服务器中是个连接（connection）对象，而在HTTp服务器中，则是请求和响应对象。后者比前者更加抽象。后者的内容更丰富，且提供请求和响应的抽象。 使用up重启HTTP服务器 npm install -g up up -watch -port 80 server.js ConnectConnect是一个基于HTTP服务器的工具集，它提供了一种新的组织代码的方式来与请求和响应对象进行交互，即中间件。 Connect能帮你封装网络应用中常见的操作。 中间件中间件能单元化地构建代码，并且能够获得高复用性。 中间件本身只是一个函数，有req，res，next这三个参数：1234567//request_time.jsmodule.exports = function (opts) &#123; return (req, res, next) &#123; //... next(); &#125;;&#125;； 使用中间件：123456789101112var connect = require('connect'), time = require('./request_time');var server = connect.createServer();//记录请求的中间件server.use(connect.logger('dev'));//时间中间件server.use(time(&#123; time: 500&#125;));server.listen(3000); 下面介绍些常用的中间件。 Static中间件挂载static允许将任意一个URL匹配到文件系统中任意一个目录。1server.use('/url',connect.static('/public/images')); maxAgestatic中间件接受一个叫maxAge的选项，这个选项代表一个资源在客户端缓存的时间。1server.use('/js',connect.static('/build/',&#123;maxAge: 10000000&#125;)); hidden托管以 . 开头的隐藏文件：1server.use(connect.static('/res/',&#123;hidden: true&#125;)); Query中间件使用了query，就能获取查询字符串这部分的数据12345server.use(connect.query);// url: /blog-posts?page=5server.use((req, res) =&gt; &#123; //req.query.page&#125;) logger中间件看名字就知道是什么了。 它提供四种日志格式： default dev short tiny1server.use(connect.logger('dev')); body.pares中间件解析POST请求的信息体,还能处理上传的文件。12345server.use(connect.bodyParser());//然乎就可以在req.body中获取信息了server.use((req, res) =&gt; &#123; //req.body.myinput&#125;); cookie和query相似，不过它是用来读写cookie。12345server.use(connect.cookieParser());//然乎就可以在req.cookies中获取信息了server.use((req, res) =&gt; &#123; //req.cookies.secret&#125;); 会话（session）它主要用来记录登录信息，作为多个请求间共享“用户会话”。判断登录信息还要靠req.body和数据库比较。 RedisRedis是一个既小又快的数据库，有一个connect-redis模块使用Redis来持久化session数据。 这样就让session驻扎到了Node进程之外。 具体实现：1234var connect = require('connect'), RedisStore = require('connect-redis')(connect);server.use(connect.session(&#123; store: new RedisStore, secret: 'secret'&#125;));]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《了不起的Node.js》摘记(1)]]></title>
    <url>%2F2017%2F08%2F29%2F%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-js%E3%80%8B%E6%91%98%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[参考链接：Node 中的流（Stream) 序看标题就知道是《了不起的Node.js》的读书笔记。在阅读的过程中会提取自己认为的重点，并简要地概括下它是什么，又怎么用。 书中有涉及不少网络方面的知识。正巧上学期刚上完计算机网络的课，脑袋里还有基本的概念。期末复习时，特地做了一张思维导图。看书的时候时常拿来参考。果然，好记性不如烂笔头，要记笔记，时常做总结。 Stream是Node.js中非常重要的API。但是书中的介绍有点少，而且还比较老。所以，就自己补充了一下。还有书中关于Event Loop的讲解，理解起来让人吃力。推荐大家看一下阮一峰老师的文章。 Javascript概览V8中的javascript获取对象上所用自建键12var obj= &#123; a:'a', b:'b' &#125;;Object.keys(obj);//['a', 'b'] 为函数命名v8能在显示堆栈信息时，将函数名显示出来，如果函数进行命名了话。 PROTO使得定义继承变得更加容易：123function Animal () &#123;&#125;function Ferret() &#123;&#125;Ferret.prototype._proto_ =Animal.prototype; 存取器访问属性使过defineGetter、设置属性使用defineSetter。1Date.prototype.__defineGetter__('name',function()&#123;&#125;); 阻塞与非阻塞IOEvent Loop原书内容不好理解，可以看阮一峰老师的文章。JavaScript 运行机制详解：再谈Event Loop 在基础架构上Node采用一个长期运行的进程。当客户端再次发送请求时，Node的进程不会初始化。所以，作用域的变量会保存修改。 Node通过使用回调函数来创建非阻塞的程序。所以在Node.js的异步编程，要使用回调函数。 Node使用Event Loop。Event Loop就是不断循环Node的主线程，处理非阻塞的程序。在Node的主线程里是不推荐放阻塞程序的。在一次Event Loop时， Event Loop都会查一下callback queue,看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 Node是单线程，所以有些情况下不遵守setTimeout设定的时间。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 错误处理Node对待错误很严格。默认情况下，如果错误没有捕获，进程就会崩溃。 堆栈追踪采用回调函数时，因为无法捕获一个未来才会执行到的函数所抛出的错误，所以，堆栈信息显示的是从事件轮询开始的。这就是为什么在Node.js中，每步都要正确处理的原因。一旦遗漏，错误很难被追踪，因为上下文信息都丢失了。 Node中的JavaScriptglobal全局对象 global: 和浏览器上的window一样。任何global对象上的属性都可以被全局访问。 process: 所用全局执行的上下文内容都在process对象中。实用全局对象console，setTimeout,nextTick(相当于setTimeout(fn,1))模块系统三个核心概念： require module exportsmodule.exports是一个对象。你可以重写它。它决定require获得什么。node通过module.exports来暴露API。 bufferbuffer是一个表示固定内存分配的全局对象。它就好比一个由8位字节元素组成的数组，可以有效地处理二进制数据。 命令行工具常用API fs.readdir(file_path,callback()); fs.readFile(file_path,’utf8’,callback()); fs.stat(file_path, callback()); 文件或目录下的元元素 process.stdin.resume()； 等待输入 process.stdin.setEncoding()； process.stdin.pause(); 暂停流 process.stdin.on(‘event’，callback())； 等待输入 process.stdout.write(); process.argv.slice(2); 获取真正的元素 process.cwd(); 获取当前目录 process.chdir(‘/‘); 灵活地更改目录 process.env变量来轻松访问shell环境下的变量 process.env.NODE_ENV 判断是运行在开发环境下，还是产品模式下。 ANSI转义码为文本添加颜色：1console.log('\033[90m' +data.replace(/(.*)/g,' $1')+'\033[39m'); \033表示转义序列开始 [表示开始颜色设置 90表示前景色是亮灰色 m表示掩饰设置结束 最后用将颜色设置回去 老的Stream当涉及持续不断地对数据进行读写时，流就出现了。 流可以分批处理文件内容：1234var stream = fs.createReadStream(&apos;my-file.txt&apos;);stream.on(&apos;data&apos;, function(chunk)&#123; //deal with files &#125;) 能这样处理文件的原因是,流是循环运行的，不结束就一直存在。这种特性在日志记录时，也很有用。打开文件的操作只要做一次。 以上是老的Stream。Stream 只是一个简单的继承自 EventEmitter 的类。就像上面的文件读取流，一旦开始读取，数据就会源源不断地读出，触发 ‘data’ 事件——嗯一开始的确是一个不错的设计，但如果你想等一下，比如说等待某个回调后再开始处理这些数据。。。好吧，每一片数据只会冒出来一次，没人消费的话它就没了；OK 你想到了用 pause-stream「暂停」一下这个流，等下再消费？完了，数据会暂存在内存中，慢慢堆积，然后，你懂了。 现在的Stream当然并不是说原来不断冒 ‘data’ 的读取方式是不好的，只是说它对于某些情景，比如文件读取，比如网络传输，没办法控制读取速度而已。网络传输注定是没办法控制读取速度的，人家给你多少你都得吃进去；但文件读取，能不能按需要，处理多少读多少呢？ Node 0.10.X 就对 Stream 做了这样的改动：默认情况下，Node 会尽可能使用「拉」模式，也就是说只有 pipe 链末端的流消费者真正需要数据的时候，数据才会从源头被取出，然后顺着管子一路到达消费者。 模拟 HTML POST 表单上传1234567891011121314var request = require('request') , FormStream = require('formstream')var form = FormStream() .field('title', 'ni dong de') .file('attachment', 'hexie.pkg')var upload = request.post('http://xxxx.xxx/upload', &#123; headers: form.headers()&#125;, function (err, res, body) &#123; // ... 略&#125;)form.pipe(upload) Stream 的精髓在于 .pipe() 嗯。 监视fs.watchFile(path,callback()); //文件 fs.watch(path,callback()); //目录]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-thunk中的柯里化]]></title>
    <url>%2F2017%2F08%2F28%2Fredux%E4%B8%AD%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[参考链接： why curry helps Thunkredux中实现异步操作的之一就是使用redux-thunk.redux-thunk中间件改造store.dispatch，使得后者可以接受函数作为参数。它的源码：1234const thunk = (store) =&gt; (next) =&gt; (action) =&gt; typeof action === 'function' ? action(store.dispatch) : next(action); 其实以上就是个柯里化函数，只不过使用了es6的写法。但是看着这么多箭头，我一开始是很懵逼的。不过，只要清楚柯里化就能轻松理解上面的代码。 什么是柯里化函数也是值。从而我们可以用有趣的方法去操作函数。柯里化允许我们把函数与传递给它的值相结合，产生一个新的函数。 换种说法就是把接受多个参数的函数变换成接受一个单一参数的函数，并且在最后返回（接受余下的参数而且返回结果的）新函数的技术。 柯里化的具体实现对于一个原本需要n个参数的函数，柯里化就是把第一个参数变量存在函数里面，然后返回一个只需要(n-1)个参数的函数。比如：12let add = x =&gt; y =&gt; x + ylet add2 = add(2) 本来完成 add 这个操作，应该是:1let add = (x, y) =&gt; x + y 它需要俩参数，而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数 并且此时 x = 2，所以此时调用1add2(3) === 2 + 3 连续箭头搞清楚里一个箭头，明白n个箭头也不难。n 个连续箭头组成的函数实际上就是柯里化了 n - 1次。 函数里的具体调用过程：前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值。 为什么要用柯里化知道了柯里化的具体实现。你有没有想过，为什么要用它呢？柯里化不就是返回一个部分配置好的函数吗？ 柯里化函数接口123456789101112//beforevar multiple = function(a, b)&#123; return +a*b + ''&#125;var concatArray = function(chars, inc)&#123; return chars.map(function(char)&#123; return multiple(char, inc); &#125;).reduce(function(a,b)&#123; return a.concat(b) &#125;);&#125;console.log(concatArray(['1','2','3'], 2)) 上面的例子的map函数是为了把所有的数字加1，再乘以2。如果我还需要数字都减2呢？是不是又要重新写multiple。是不是很麻烦，那怎么能把他提取出来呢？来对比下柯里化的解法：1234567891011121314151617181920//aftervar multiple = function(a)&#123; return function(b)&#123; return +b*a + '' &#125;&#125;var plus = function(a)&#123; return function(b)&#123; return (+b)+a + '' &#125;&#125;var concatArray = function(chars, stylishChar)&#123; return chars.map(stylishChar) .reduce(function(a,b)&#123; return a.concat(b) &#125;);&#125;console.log(concatArray(['1','2','3'], multiple(2)))console.log(concatArray(['1','2','3'], plus(2))) 有什么不一样呢 处理数组中字符的函数被提取出来, 作为参数传入 提取成柯里化的函数, 部分配置好后传入, 好处显而易见, 这下接口非常通畅 无论是外层调用1concatArray(['1','2','3'], multiple(2)) 还是内部的 map 函数1chars.map(stylishChar) chars.map(stylishChar)这些接口都清晰了很多, 不是吗 这就是函数式的思想, 用已有的函数组合出新的函数, 而柯里化每消费一个参数, 都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段, 并且使得接口更为流畅. 再加上自动柯里化的库 ramda, 简直就完美了 var multiple = ramda.curry(function(a, b){ return +b*a + ‘’})var plus = ramda.curry(function(a, b){ return (+b)+a + ‘’})1JS Bin&lt;script src="http://static.jsbin.com/js/embed.js"&gt;&lt;/script&gt; 回归正题现在回头看thunk的源码。 它只不过是提前传递了store，供函数形式的action使用。以及next，代表下一个中间件。而最后一个参数’action’像任何其他中间件一样。 不然的话，我们只是把结果传递给链中的下一个中间件而已。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局(二):Flex]]></title>
    <url>%2F2017%2F08%2F24%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[去看阮一峰老师的两篇博文吧。 这篇文章可以说是给我自己看的。 记忆方法基本概念首先要搞清楚基本概念，知道flex中的主轴，main start， main end等概念，不然你会两眼一抹黑，一点空间概念也没有。 基本概念有了，可以分容器属性和项目属性两类记忆 容器属性flex-direction,flex-wrap,flex-flow flex-direction属性决定主轴的方向。 flex-wrap决定换不换行和是否逆序排列。 flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content， align-items，align-content这三属性是有关项目的。 align-items属性定义项目在交叉轴（边框）上如何对齐。 justify-content属性定义了项目在主轴上的对齐方式。 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 项目属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。当成布尔值就是了。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size） flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 总结重要的还是多实践。不多说了，我要去实际练习。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局(-):传统]]></title>
    <url>%2F2017%2F08%2F24%2Fcss%E5%B8%83%E5%B1%80(-)%3A%E7%9B%92%E6%A8%A1%E5%9E%8B-display-float-position%2F</url>
    <content type="text"><![CDATA[参考链接：http://zh.learnlayout.com/ 这个网站真的很棒。实例好，讲解清楚。不急的话，可以直接看他的。 不过我关于浮动和清除的介绍比他详细点，另外还有重置样式表。别忘了回来哦。 传统布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 这篇主要介绍一下传统布局，下篇将Flex。 盒模型每一个元素都会在页面上生成一个盒子。因此，HTML 页面实际上就是由一堆盒子组成的。 在CSS中，使用标准盒模型描述这些矩形盒子中的每一个。这个模型描述了元素所占空间的内容。每个盒子有四个边：外边距边, 边框边, 内填充边 与 内容边。 box-sizing当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。 重置样式表CSS reset的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”！1234567//一般网站的推荐写法body, dl, dd, h1, h2, h3, h4, h5, h6, p ,form &#123; margin:0;&#125;ol,ul &#123; margin:0; padding:0;&#125; 浮动和清除浮动浮动，你看这俩字儿多形象，意思就是把元素从常规文档流中拿出来。 拿出 来干什么?一是可以实现传统出版物上那种文字绕排图片的效果，二是可以让原来 上下堆叠的块级元素，变成左右并列，从而实现布局中的分栏。 当你浮动一个元素的时候……这些(浮动)规则就好像 在说:“尽量把这个元素往上放，能放多高放多高，直到碰到某个元素的边界为止。” clearclear 属性被用于控制浮动。 clear CSS 属性指定一个元素是否可以在它之前的浮动元素旁边，或者必须向下移动(清除浮动) 在它的下面。clear 属性适用于浮动和非浮动元素。 清除浮动浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。父元素会收缩到没它一样。这往往混乱页面的布局。所以我们需要使父元素围住浮动元素。 那怎么办呢？ 通过简单的给父元素加上 class=”clearfix” 做到。123.clearfix &#123; overflow: auto;&#125; 这个可以在现代浏览器上工作。如果你想要支持IE6，你就需要再加入如下样式：1234.clearfix &#123; overflow: auto; zoom: 1;&#125; 没有父元素时，使用clear通过给元素应用clear：both，强迫它定位在前一个浮动元素的下方。 没有父元素，且空间足以容纳多个元素上浮动时，还是使用.clearfix大法。不过这次是给子元素用。 1234567.clearfix:after &#123; content:"."; display:block; height:0; visibility:hidden; clear:both;&#125; 它只添加一个清除的包含句点为非浮动元素。规则中的其他声明只是为了确保这个伪元素没有高度，且不可见。就像有条看不见的分割线，拦住了从下往上冲的元素。 Displaydisplay 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。一个 block 元素通常被叫做块级元素。一个 inline 元素通常被叫做行内元素。 none另一个常用的display值是 none 。一些特殊元素的默认 display 值是它，例如 script 。 display: none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。 它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。 inline-block一种创建网格布局的简单方法。 你得做些额外工作来让IE6和IE7支持 inline-block 。有些时候人们谈到 inline-block 会触发叫做 hasLayout 的东西，你只需要知道那是用来支持旧浏览器的。如果你对此很感兴趣，可以在前面那个链接中找到更详细的信息。否则我们就继续下去吧。 Positionstaticstatic 是默认值。任意 position: static; 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。 relativerelative 表现的和 static 一样，除非你添加了一些额外的属性。 在一个相对定位（position属性的值为relative）的元素上设置 top 、 right 、 bottom 和 left 属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。 fixed一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。 absoluteabsolute 是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语言精粹(2)：对象、函数]]></title>
    <url>%2F2017%2F08%2F20%2FJs%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(2)-%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[对象Javascript的简单数据类型包括数字、字符串、布尔值、null值和undefined值。其他所有的值皆是对象，包括数组、函数和正则表达式。 Javascript中的对象是可变的键控集合。对象是属性的容器，其中属性由键值对构成。 Javascript包含一种原型链的特性，允许对象继承另一个对象。正确的使用它能减少对象初始化时消耗的时间和内存。 ES6中新加入了Class。但这个Class只是简洁了Javascript的语法，让人看上去更清爽。详情见深入浅出ES6（十三）：类 Class 对象字面量一个对象字面量就是包围在一对花括号中的零或多个键值对。对象还是可嵌套的。123456789var flight = &#123; airline_name: "Oceanic", "airline-number": 815, departure: &#123; IATA: "SYD", time: "2017-08-20 13:27", city: "HangZhou" &#125;&#125; 检索属性有两种方式，. 表示法，或object[attr]数组访问法，各有用途。 .表示法用于当要检索的属性为不变常量时，可读性更好，强烈推荐用。 数组访问法在属性为字符串变量时，必用（此时点表示法失效）。 12stooge["first-name"]flight.departure.IATA 引用引用传值都是浅复制。 当你需要某个对象的一份拷贝时，一定要用深复制。 12//对于 JSON 安全的对象(只有由对象和数组组成的对象)，我们的深复制非常简单var newObj = JSON.parse(JSON.stringify(obj)); 当你需要共享某一个对象时，即需要多个变量对同一个对象进行操作，一定要用浅复制 1234_.clone = function(obj) &#123; if (_.isObject(obj)) return obj; return _.isArray(obj) ? obj.slice : _.extend(&#123;&#125;,obj);&#125;; 反射反射用于描述能够检查同一系统（或其自身）中的其他代码的代码。 简单点说。在你不知道一个对象内部结构的情况下(你甚至连这个对象的一个属性，或api都不知道)，怎么跟他通信呢？这个时候就要通过一种机制，得到它的内部结构。这种机制就叫做反射。说白了，窥探对象内部结构的方法就叫做反射。 typeof和hasOwnProperty都是很好的例子。 枚举for infor in 的迭代无序，且包括原型链。虽然可以通过hasOwnProperty()和typeof来过滤. 删除1delete another.name; 函数函数包含一组语句，是js 的基础模块单元，用于代码复用、信息隐藏和组合调用。函数用于制定对象的行为。 函数对象除了一般函数，其他所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身. Function构造器产生函数对象，会运行类似这样的代码：123this.prototype = &#123; constructor: this&#125;; Function.prototype的proto指向 Object.prototype, Object.prototype.proto === null .prototype是一个对象的原型对象,而proto则是对原型对象的引用。 Object实际上是一个函数，所以可以Object()。 函数的与众不同之处在于他们可以被调用。 函数字面量123var add = function (a,b) &#123; return x + y ;&#125;; 通过函数字面量创建的函数对象包含一个连到外部上下文连接。这被称为闭包. 调用this的值取决于调用的模式，因为this是延迟绑定的。this到对象的绑定发生在调用时。 方法调用模式this绑定调用方法的对象。1234567var myObject = &#123; value: 0, increment: function (inc) &#123; return this.value += typeof inc === 'number' ? inc : 1; &#125;&#125;;myObject.increment(1); 函数调用模式当一个函数不是对象的属性时，他就是被当作函数来调用。此时this绑定到全局对象.1var sum = add(3,4); 这样直接导致的后果是add方法不能利用内部函数来帮助它工作。因为内部函数的this被绑定了错误的值，所以add不能访问对象的属性。 好在可以通过给add方法传入赋值了this的变量，来解决。 解决办法：12345678910myObject.double = function () &#123; var that = this; var helper = function () &#123; that.value = add(that.value,that.value); &#125;; helper();&#125;myObject.double();document.writeln(myObject.value); 构造器调用模式javascript对原型继承不自信的表现。 如果在一个函数前面带上 new 调用，那么背地里将会创建一个新对象。新对象连接到该函数的prototype成员。12345678var Quo = function (string) &#123; this.status = string;&#125;Quo.prototype.get_status = function () &#123; return this.status;&#125;;var myQuo = new Quo('happy');document.writeln(myQuo.get_status()); Apply调用模式javascript是一门函数式的面向对象编程语言，所以函数可以拥有方法。 apply方法帮助我们构建一个参数数组传递给调用函数。它能帮助函数设置this。1234567var statusObject = &#123; status: 'OK'&#125;;//把get_status方法内的作用域换成statusObject的作用域。//即使statusObject没有继承自Quo.prototype,但我们可以在statusObject上调用get_status.var status = Quo.prototype.get_status.apply(statusObject);//status的值为OK。 call()方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 扩充类型功能Javascript允许给语言的基本类型扩充功能。而且给原型扩充时，是动态的。123456Function.prototype.method = function(name, func)&#123; if(!this.prototype[name])&#123;//如果方法已存在，就不添加 this.prototype[name] = func; &#125; return this;&#125;; 递归递归函数就是会直接或间接调用自身的函数。它把一个问题分为一组相似的子问题，每一个都用一个寻常解去解决。 javascript解决汉诺塔问题：1234567var hanoi = function(num，one, two，three)&#123; if(num &gt; 0)&#123; hanoi(num - 1, one, three, two) document.writeln('MOVE num'+num+' from '+one+' to '+ three); hanoi(num-1,three, one, two) &#125;&#125; ##作用域、闭包见我的另一篇文章 回调函数回调函数（callback）是什么？ - 回答作者: no.body 级联返回this的方法，就可以启动级联。 记忆一个函数能帮我们构造带记忆功能的函数。1234567891011var memorizer = (memo, formula) =&gt; &#123; var recur = (n) =&gt; &#123; var result = memo[n]; if(typeof result !== 'result') &#123; result = formula(recur, n); memo[n] = result; &#125; return result; &#125; return recur;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语言精粹(1)-精华与糟粕]]></title>
    <url>%2F2017%2F08%2F19%2Fjs%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9(1)-%E7%B2%BE%E5%8D%8E%E4%B8%8E%E7%B3%9F%E7%B2%95%2F</url>
    <content type="text"><![CDATA[序本文是《Javascript语言精粹》的笔记和思考。 参考链接:SimplyY/blog 为什么要使用Javascript 你没有其他选择。web已变成一个重要的应用开发平台，而javscript是唯一一门所有浏览器都可以识别的语言。 javascript虽然有缺陷，但它真的很优秀。它既轻量又富有表现力。而且，你一旦掌握了它，就会发现函数式编程的魅力。任何语言都有精华和糟粕。我们要取其精华，弃其糟粕。况且，你有权利定义你自己的子集。我们完全可以基于精华部分去编写更好的程序。 Javascript优点 是弱类型语句。 有非常强大的对象字面量表示法。 基于原型继承的动态对象。 函数是顶级对象。函数可以调用方法。Javascript的继承可以借此特性实现。 Javascript缺点以解决办法使用 jshint 或者其他的一些 linter 插件工具来避免自己使用糟糕的特性。 全局变量 javascript依赖全局变量来进行连接。所有编译单元的所有顶级变量被撮合到名为“全局变量”的公共命名空间中。 可以使用es6的let，IIFE等方法解决。 + +的两个运算数只要一个不是 number 类型，+ 就会做字符串拼接。 parseInt(str, int) parseInt(str, int) 遇到非数字会自动停止解析，请一定加上第二个参数来设置进制. 不然假如第一个参数是零开头就会以8进制求值，比如”08”，返回零，因为8进制没有”8” 浮点数0.1 + 0.2 不等于0.310.3 - 0.1 // 0.19999999999999998 使用js库 https://github.com/MikeMcl/decimal.js123x = new Decimal(0.3)x.minus(0.1) // '0.2'x // '0.3' 判断value是不是数字1Number.isFinite('0'); //false 和全局的isFinite()函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 true。 1234567Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0) // true// 下面这几个如果使用全局的 isNaN() 时，会返回 true。Number.isNaN("NaN"); // false，字符串 "NaN" 不会被隐式转换成数字 NaN。Number.isNaN(undefined); // falseNumber.isNaN(&#123;&#125;); // false 和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。 js没有真正的数组123456typeof [] // 'object'//检测一个值是不是数组function isArray(value) &#123; return Object.prototype.toString.apply(value) === '[object Array]'&#125; null和undefined的区别null表示一个空值对象，即不存在的对象。当声明的变量还未被初始化时，变量的默认值为undefined。null还是一个对象，undefined就表示没有。 null典型用法是： 作为函数的返回值，表示该函数本应该返回对象，但是找不到，即为不存在的对象的意思。 作为对象原型链的终点。 调用函数时，作为缺省的参数。比如1Math.max.apply(null, array); undefined 典型用法是： 变量或对象属性被声明了，但没有赋值时，就等于 undefined。 调用函数时，未传入参数，函数内部该参数等于 undefined。 函数没有返回值时，默认返回 undefined。1Object.getPrototypeOf(Object.prototype); // null]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基础]]></title>
    <url>%2F2017%2F08%2F11%2Fwebpack%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[webpack模块化开发webpack本身就是一款用户打包前端模块的工具。主要是用来打包在浏览器端使用的javascript的。同时也能转换、捆绑、打包其他的静态资源，包括css、image、font file、template等 要了解它，首先要知道什么叫模块化开发。 前端开发中，起初只要在script标签中嵌入几十上百行代码就能实现一些基本的交互效果，后来js得到重视，应用也广泛起来了，jQuery，Ajax，Node.Js，MVC，MVVM等的助力也使得前端开发得到重视，也使得前端项目越来越复杂，然而，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块了。但javascript可以实现模块，一个定义了私有变量和函数的函数。 什么鬼，什么叫定义了私有变量和函数的函数？不知道的同学，可以去看一下《javascript语言精粹》的模块章节。 简单地讲，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 这就是模块化开发。而webpack能将依赖的模块转化成可以代表这些包的静态文件。 Webpack它的目标是什么？它和其他类似的工具有什么不同？webpack为什么要将所有资源放在一个文件夹里？详情请见《webpack学习之路》 webpack.config.js详解看代码说话：12345678910111213141516171819202122232425262728293031323334353637383940var webpack = require('webpack');var path = require('path');var config_webpath_dev = require('./configs/webpack_dev');var config = &#123; resolve: &#123; alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125; &#125;, entry: ['./src/index'], output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurenceOrderPlugin() ], module: &#123; loaders: [&#123; test: /\.css$/, loaders: ['style', 'css'] &#125;] &#125;, devServer: &#123; contentBase: "./public", colors: true, historyApiFallback: true, inline: true, hot: true, host: config_webpath_dev.domain, port: config_webpath_dev.port &#125;,&#125;module.exports = config; resolve 这些选项能设置模块如何被解析alias配置项，可以为常用模块配置改属性，可以节省编译的搜索时间。例如：12345resolve:&#123; alias:&#123; 'react':path.join(nodeModulesPath,'react/react.js') &#125; &#125; entry 是指入口文件的配置项，它是一个数组的原因是webpack允许多个入口点。output是指输出文件的配置项 path - 表示输出文件的路径 filename - 表示输出文件的文件名 plugins 顾名思义，使用插件可以给webpack添加更多的功能，使webpack更加的灵活和强大,webpack有两种类型的插件:webpack内置的插件12345678910// 首先要先安装webpack模块var webpack = require("webpack");module.exports = &#123; new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;)h&#125;; webpack外置插件1234567//npm install component-webpack-plugin 先要在安装该模版var ComponentPlugin = require("component-webpack-plugin");module.exports = &#123; plugins: [ new ComponentPlugin() ]&#125; 更多的插件以及插件的用法，大家可以到webpack的插件上查看。 module 决定了如何处理项目中的不同类型的模块。它通过配置要使用的loader，把资源文件（css、图片、html等非js模块）处理成相应的js模块,然后其它的plugins才能对这些资源进行下一步处理。比如babel-loader可以把es6的文件转换成es5。loaders 一个含有wepback中能处理不同文件的加载器的数组 test 用来匹配相对应文件的正则表达式 loaders 告诉webpack要利用哪种加载器来处理test所匹配的文件loaders 的安装方法1$ npm install xxx-loader --save-dev devServer(webpack-dev-server) 能够用于快速开发应用程序 color - Enables/Disables colors on the console. contentBase - 告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。 historyApiFallback - 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html. hot - 启用 webpack 的模块热替换特性. inline - 默认情况下，应用程序启用内联模式(inline mode)。这意味着一段处理实时重载的脚本被插入到你的包(bundle)中，并且构建消息将会出现在浏览器控制台。 host - 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问，指定如下： port - 指定要监听请求的端口号]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML和CSS杂记]]></title>
    <url>%2F2017%2F08%2F09%2Fcss%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[CSS要点《css设计指南》笔记 HTMLsection只有元素内容会被列在 文档大纲 中时，才适合用section元素。 这里的文档大纲更像是提纲，section 就是提纲中的不重复项（比如对于博文 list，整个 list 才属于一个 section） 块级元素和行内元素块级元素盒子会扩展到与父元素同宽 明确设定 width 属性后，块级元素就不会再扩展到与父元素(即 body)同宽了。没有设定 width，值为 auto。行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧。 CSS伪类伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。 UI伪类会在 HTML 元素处于某个状态时(比如鼠标 指针位于链接上)，为该元素应用 CSS 样式。 结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第一个或最后一个)，为相应元素应用 CSS 样式。UI伪类 链接伪类(link 未被点，visited 已被点，hover 鼠标悬停，active 正在被点) :focus 伪类 表单中的文本字段在用户单击它时会获得焦点，获得焦点时使用 css 样式。 :target 伪类，用户点击一个指向页面中其他元素的链接。常用于页面内跳转里，来显示跳转到的位置，使用举例1&lt;a href="#more_info"&gt;More Information&lt;/a&gt; 位于页面其他地方、ID 为 more_info 的那个元素就是目标。该元素可能是这样的:1&lt;h2 id="more_info"&gt;This is the information you are looking for.&lt;/h2&gt; 那么，如下 CSS 规则1#more_info:target &#123;background:#eee;&#125; 会在用户单击链接转向 ID 为 more_info 的元素时，为该元素添加浅灰色背景。 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。 ::first-letter 伪元素 :1p::first-letter &#123;font-size:300%;&#125; 可以得到段落首字符放大的效果。 ::first-line 伪元素 ::before 和::after 伪元素 :12p.age::before &#123;content:"Age: ";&#125;p.age::after &#123;content:" years.";&#125; 伪类与伪元素的区别伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 权重浏览器通过权重来判断哪一些属性值与一个元素最为相关，从而在该元素上应用这些属性值。优先级是基于不同种类选择器组成的匹配规则。 权重是如何计算的？优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。 而当优先级与多个CSS声明中任意一个声明的优先级相等的时候，CSS中最后的那个声明将会被应用到元素上。 当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的CSS规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。 MORE 背景 background-color background-image background-repeat background-position background-size background-attachment background(简写属性) 背景图片123p &#123; background-image:url(images/turq_spiral.png);&#125; 背景重复repeat(默认),repeat-x,repeat-y,no-repeat. 背景位置123p#center &#123; background-position:center;//top,left,bottom,right&#125; 多背景图片12345p &#123; background: url(images/turq_spiral.png) 30px -10px no-repeat, url(images/pink_spiral.png) 145px 0px no-repeat, url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75; &#125; 背景渐变线性渐变12345678.gradient1 &#123;background:linear-gradient(#e86a43, #fff);//从上到下&#125;.gradient3 &#123; background:linear-gradient(-45deg, #e86a43, #fff);//从左上到右下&#125; .gradient2 &#123; 1 background:linear-gradient(left, #64d1dd, #fff);&#125; 渐变点12345678.gradient1 &#123; background:linear-gradient(#e86a43 20%, #fff 50%, #e86a43 80%); &#125;.gradient3 &#123; background:linear-gradient(#64d1dd, #fff 25%, #64d1dd 50%, #fff 75%, #64d1dd);&#125;.gradient4 &#123;background:linear-gradient(#e86a43, #fff 25%, #64d1dd 25%, #64d1dd 75%, #fff 75%, #e86a43);&#125; 放射性渐变123456789.gradient1 &#123;background: -webkit-radial-gradient(#fff, #64d1dd, #70aa25); &#125;.gradient2 &#123; background: -webkit-radial-gradient(circle, #fff, #64d1dd, #e86a43); &#125;.gradient3 &#123; background: -webkit-radial-gradient(50px 30px, circle, #fff, #64d1dd,#4947ba); &#125; 字体和文本字体族1body &#123;font-family: "Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;&#125; 在指定文本的字体时，需要多列出几种后备字体， 以防第一种字体无效。这个字体的列表也叫字体栈。 字体类 serif，也就是衬线字体 sans-serif，也就是无衬线字体 monospace，也就是等宽字体 cursive，也就是草书体或手写体 fantasy，不能归入其他类别的字体(一般都是奇形怪状的字体)。使用这些通用字体类的目的，就是确保在最坏的情况下，文档起码可以通过正确的字形来显示，将通用字体类写到最后即可。 字体样式值:italic、oblique、normal。 示例:h2 {font-style:italic;} 。 文本属性 文本缩进: text-indent 字符间距: letter-spacing 单词间距: word-spacing 文本对齐: text-align，值:left、right、center、justify。 行高: line-height 文本装饰: text-decoration，值:underline、overline、line-through、none。 表单12&lt;form class='style_form' action='process_form.php' method='post'&gt;&lt;/form&gt; action 用于指定服务器上用来处理表单数据的文件的URL。 method (值要么是post，要么是get)用于指定怎么把数据发送到服务器上。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的重要性]]></title>
    <url>%2F2017%2F07%2F23%2FCSS%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS玉伯看HTML和CSS代码的背后https://github.com/lifesinger/blog/issues/105&gt; 之前在freeCodeCamp上看到两篇置顶的前端入门文章。第一篇的内容涉及html和css。第二篇就讲javascritpt。看第一篇内容时，真是被文章丰富的内容吓了一跳。当时心里就嘀咕，真的要学这么多吗？ 直到今天看了玉伯的文章，才意识到html和css同样非常重要。所以，特地做一下笔记，把所思所想理一下。 让块元素水平居中。一般大家都会写成：1234.content &#123; width: 980px; margin: 0 auto;&#125; 上面的代码能正常工作，大部分情况下也不会有问题，但上面的代码存在思维的懒惰。应该写成:12345.content &#123; width: 980px; margin-left: auto; margin-right: auto;&#125; 看起来代码变多了，变啰嗦了。但如果你真的了解 margin: 0 auto 的话，就能明白其中的意义。 margin: 0 auto 的实现：123456&#123; margin-top:0; margin-bottom:0; margin-left:auto; margin-right:auto;&#125; 可以看到 margin: 0 auto 中会帮你把top和bottom重置了。可是，你只想要“水平居中”而已。 这种不纯粹会导致顺序和优先级的依赖，比如有另一处要给 margin-top/bottom 赋值时，就必须要提高优先级。 而且 margin: 0 auto 中的 0 绝大部分情况下是冗余的，页面上早就有 reset.css 或 normalize.css 重置过。 最小影响原则你在写某段CSS代码时，首先要非常清楚地知道这段CSS代码的功能，其次要尽量严格保障这段CSS代码只实现了你想要实现的功能。 这就如医生动手术，好好做好本分就行，千万别留下一个小镊子在病人身体里。 与HTML代码一样，对CSS代码来说，很重要的两个衡量标准也是稳定和灵活。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js基础：作用域、闭包、this]]></title>
    <url>%2F2017%2F07%2F22%2FJs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81this%2F</url>
    <content type="text"><![CDATA[作用域词法作用域：描述了源代码中的范围。 if语句或while语句以及其他类似循环结构的语句块不能创建新的作用域。只用function语句块能创建新的作用域。 执行环境：当程序运行的时候，会创建一个存储变量和变量值的存储系统。这些内存中的作用域结构被称为执行环境。 执行环境和词法作用域的不同：执行环境实在程序运行时才被创建的，不是在代码输入时被创建的。执行环境能控制在程序执行过程中不同点能访问哪些变量。注：12345var test=function()&#123;&#125;;var test1=test();var test2=test();log(test1===test2);//falsejavascript不对对象进行引用 闭包闭包是指一些函数通过某种方式可以随时被访问，即使它的外部代码已经执行完毕。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 常见的闭包的现象，如通过函数字面量创建的函数对象包含一个连到外部上下文的连接。123var hello = function (a，b) &#123; return a + b；&#125; 保留函数访问权限的方法 passing to setTimeout 从函数中return 123456789function f1()&#123; var n=999;//只要内部函数需要，n会持续保留 function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 保存为全局变量 用处 设计模块中的私有属性和方法（闭包中的自由变量无法被直接访问） 让这些变量的值始终保持在内存中(可以被延迟调用，比如事件 handler，ajax 异步调用的回调函数等)。 Thisthis指调用函数的那个对象 使用new的时候会发生什么 创建一个新的空对象；//Object.create(); 将this绑定到该对象； 添加一个名为proto的新属性，并且指向构造函数的原型(prototype)； 返回该this对象。//return this; this的用法 纯粹的函数调用: this 就代表全局对象 Global（浏览器下就是 window）。 作为对象方法的调用: this 指向调用方法的对象。 作为构造函数调用：this 就指向 构造器创建的新对象 apply, call, bind调用：this 指向就是这些函数的第一个参数 原型链当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止（这种行为我们也称之为委托）。 原型链是使用其他对象属性的一种方式。 原型链的属性复制发生在当前查找的时候，所以是实时更新的。 Javascript为什么会有prototype]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js语法基础：Array、String常用方法]]></title>
    <url>%2F2017%2F07%2F22%2FJs%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%9AArray%E3%80%81String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Array ECMAScript数组的大小是可以动态调整的，既可以随着数据的添加自动增长以容纳新增数据。当把一个值放在超出当前数组大小的位置上时，数组就会重新计算长度值，即长度值等于最后一项的索引加一，前面的值都自动被赋值为了undefined了。 Array.prototype.concat()concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。123var one=['a','b'];var two=['d','c'];var three=one.concat(two);//three[a,b,c,d] one[a,b] two[c,d] 描述 concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里. 简单的说 concat不修改原数组 concat是浅复制，只是对于数组包含的元素的复制。 队列、堆栈Array.prototype.shift()shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 Array.prototype.unshift()The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array. Array.prototype.push()The push() method adds one or more elements to the end of an array and returns the new length of the array. Array.prototype.pop()The pop() method removes the last element from an array and returns that element. This method changes the length of the array. Array.join(separator)数组格式化输出，返回字符串。以 separator 分隔，separator 默认为’,’1[1,2,3].join(' ') // '1 2 3' Array.prototype.slice(begin,end)返回数组中的一部分的浅复制到一个新的数组对象，只对数组中的元素进行浅复制。原始数组不会被修改。12345var a = ['zero', 'one', 'two', 'three'];var sliced = a.slice(1, 3);console.log(a); // ['zero', 'one', 'two', 'three']console.log(sliced); // ['one', 'two'] Array.prototype.splice(start, deleteCount, items…)splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 高阶函数Array.prototype.forEach()forEach() 方法对数组的每个元素执行一次提供的函数。 Array.prototype.reduce()reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array)&#123; return accumulator + currentValue;&#125;);// 10 描述reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数： accumulator 初始值（或者上一次回调函数的返回值） currentValue 当前元素值 currentIndex 当前索引 array 调用 reduce 的数组。 回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。 Array.prototype.map()map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 callback 函数会被自动传入三个参数：当前数组元素，当前元素索引，原数组本身 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] Array.prototype.filter()The filter() method creates a new array with all elements that pass the test implemented by the provided function. 1234567var words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];var longWords = words.filter(function(word)&#123; return word.length &gt; 6;&#125;)// Filtered array longWords is ["exuberant", "destruction", "present"] [数组的其他方法和属性]（https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array）Stringstring.charAt(pos)返回只含一个字母的字符串 string.indexOf(searchString, position)返回字符串里面的字母所在的位置下标，实际上把 string 看成一个 char[]，更容易理解 string.slice(start, end)返回子字符串，参数可以为负数 string.match(regexp)返回比配字符串，假如有正则表达式为/xxx/g则，返回一个数组，否则返回第一次匹配到的字符串 string.replace(searchValue, replaceValue)替换字符串，searchValue 可以为正则表达式。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人工智能狂潮》摘记]]></title>
    <url>%2F2017%2F05%2F23%2F%E3%80%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8B%82%E6%BD%AE%E3%80%8B%E6%91%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是人工智能？专家观点：尚未统一。作者的定义是，人工智能是“用人工方法制作的类人智能”，类人智能指的是具有“发现和觉察功能”的计算机，即能够从数据中生成特征量，并对相关现象进行模型化处理的计算机。 人工智能的发展历史人工智能的研究是从以“推理”为重点到以“知识”为重点，再到以“学习”为重点，一条自然、清晰的脉络。 第一次人工智能狂潮的局限（20世纪60年代）计算机只能解决所谓的“玩具问题”。求解迷宫问题，挑战国际象棋及将棋，这些都只需要在明确定义好的规则中考虑下一步如何走起即可，然而，现实生活中的问题却要复杂得多。 第二次人工智能狂潮的局限（20世纪80年代末）永无穷尽的知识Example: He saw a woman in the garden with a telescope. 理解这句话，需要一般性的常识。而计算机要处理一般性的常识，就需要掌握人类所拥有的，永运也无法写尽的海量知识，这是极其困难的。因为，同样的事情在所有的各种各样的场合皆会发生。 它用望眼镜看到一个女人在花园呢？还是他在公园用望眼镜看到一个女人？ 框架问题框架问题，就是执行某项任务时“仅仅提取出与它相关的知识并对其加以运用”，这对人类来说简单的事，但对计算机来说是困难无比的。 认识框架问题 符号接地问题是否能将符号（词语,语言）与它所表示的意义连接起来。 日本在1982年启动了名为“第五代计算机”的国家级项目，从1982年开始前后跨越了10年，总共投入了570亿日元。尽管没有实现预定目标，但是它聚集了人工智能研究的优秀人才，还吸引了众多的海外知名专家，并由此建立了相关的人才联系网络。 第三次人工智能狂潮（机器学习，深度学习）机器学习机器学习，一种实现人工智能的方法。 它是使用算法来分析数据的实践、学习，然后对真实的事件作出决定或预测。而不是用一组特定的指令生成的硬编码软件程序来解决特定任务。机器是通过使用大量的数据和算法来「训练」，这样就给了它学习如何执行任务的能力。 机器学习的难点机器学习最关键的地方是如何把一个把原始数据转变成特征量。这些特征量可以很好的描述这些数据，并且利用它们建立的模型在未知数据上的表现性能可以达到最优（或者接近最佳性能）。从数学的角度来看，特征工程就是人工地去设计输入变量X。 可惜的是特征量的设计必须由人来做。 特征量，指的是机器学习在输入时所使用的变量，其值是对对象特征的定量表示。 深度学习wiki上的解释： 深度学习（英语：deep learning）是机器学习拉出的分支，它试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。 深度学习， 一种实现机器学习的技术。它能自己产生特征量。其实回过头看，人工智能的发展其实是给予机器越来越抽象的基本信息。 至于深度学习的实现过程，我其实也是模模糊糊。等有深入了解后，再来改进这篇文章。]]></content>
      <categories>
        <category>编程之外</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读Android原生计算器源码]]></title>
    <url>%2F2017%2F05%2F17%2F%E9%98%85%E8%AF%BBAndroid%E5%8E%9F%E7%94%9F%E8%AE%A1%E7%AE%97%E5%99%A8%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Read Android Original Calculator项目结构 Calculator CalculatorPadLayout CalculatorNumericPadLayout CalculatorPadViewPager CalculatorExpressionBuilder CalculatorExpressionEvaluator CalculatorExpressionTokenizer CalculatoronBackPressed()处在第高级操作符页面时，点击back键，返回初始页面。 onUserInteraction()Called whenever a key, touch, or trackball event is dispatched to the activity. 在处理用户交互前，如果由正在进行的动画请立即终止。 onEquals()至于计算，只要获得式子的字符串，然后交给 org.javia.arity.Symbol就行了。12//一句话的事double result = mSymbols.eval(expr); CalculatorPadViewPager为什么在显示page1的时候page2会显示出来一部分呢（右侧青色那一条）？答案在setPageMargin(-24);由于是负数，这样每个page之间就会有重叠，就出现了明明显示的第一个view，结果在右侧显示了一部分第二个view的layout。 为什么向左滑动的时候page1的位置一直保持不动？不应该是向左侧滑出吗？看setPageTransformer(false, mPageTransformer); 123456789/*** Apply a property transformation to the given page.** @param page Apply the transformation to this page* @param position Position of page relative to the current front-and-center* position of the pager. 0 is front and center. 1 is one full* page position to the right, and -1 is one page position to the left.*/public void transformPage(View page, float position); 看一下源码里的方法说明，这里的position其实是相对的，并不是常规理解的位置下标，它是以当前屏幕的正中心为坐标原点，当page的中心和屏幕的原点重合（即page正在完全显示时）position=0;当page向左侧滑动，慢慢淡出屏幕时，该过程中page的中心相对屏幕的中心原点在沿着X轴向左移动，此时positon &lt; 0，当page完全滑出屏幕时，positon = -1;同理，当page向右滑动，慢慢淡出屏幕时，该过程中page的中心相对屏幕的中心原点在沿着X轴向右移动，此时positon &gt; 0，当page完全滑出屏幕时，positon = 1； 有了上面的分析，其实可以把positon看成正在滑动的page滑出屏幕的比例，正负代表往哪个方向滑动。所以，要想在滑出数学计算公式的page过程中保持当前输入的page位置不动，根据滑出屏幕的比例设置该page在X轴的偏移量就可以了，view.setTranslationX(getWidth() * -position); 同理，把数学计算公式的page滑出时取消这个偏移量，view.setTranslationX(0); 到这里疑问2也解决了。 更多的ViewPager切换动画请参考开源项目JazzyViewPager 还有就是当page2滑出后宽度为什么没有铺满、左边还要留出一部分透明区域呢？原来是复写了PagerAdapter的getPageWidth方法，看一下该方法的说明： 12345678910/** * Returns the proportional width of a given page as a percentage of the * ViewPager's measured width from (0.f-1.f] * * @param position The position of the page requested * @return Proportional width for the given page position */public float getPageWidth(int position) &#123; return 1.f;&#125; 说的很清晰了，根据position设置当前页面宽度的百分比。 123public float getPageWidth(int position) &#123; return position == 1 ? 7.0f / 9.0f : 1.0f; &#125; OnPageChangeListener解读Callback interface for responding to changing state of the selected page. OnPageChangeListener这个接口需要实现三个方法：（onPageScrollStateChanged，onPageScrolled ，onPageSelected）：onPageScrollStateChanged(int arg0) ，此方法是在状态改变的时候调用，其中arg0这个参数。有三种状态（0，1，2）。arg0 ==1的时辰默示正在滑动，arg0==2的时辰默示滑动完毕了，arg0==0的时辰默示什么都没做。 onPageScrolled(int arg0,float arg1,int arg2) ，当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为： arg0 :当前页面，及你点击滑动的页面 arg1:当前页面偏移的百分比 arg2:当前页面偏移的像素位置 onPageSelected(int arg0) ： 此方法是页面跳转完后得到调用，arg0是你当前选中的页面的Position（位置编号）。 CalculatorPadLayout自定义了数字键盘的布局。规定了每个按键的长宽高，以及位置。 CalculatorNumericPadLayout extends CalculatorPadLayout根据id设置按钮属性。 总结原本不知道怎么实现的效果，发现方法其实很简单。当然，你得对源码很了解，才能想到。 小要点SpannableStringBuilderThis is the class for text whose content and markup can both be changed TextWatchWhen an object of a type is attached to an Editable, its methods will be called when the text is changed.]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Contentprovider]]></title>
    <url>%2F2017%2F04%2F28%2F%E7%90%86%E8%A7%A3Contentprovider%2F</url>
    <content type="text"><![CDATA[How to use content providerwhat is a content provider?content provider是位于应用和其数据源之间地类。它能让应用轻松地访问相关数据源，并且访问过程得到管理。 why is it useful? 作为额外地抽象化操作，它允许开发者更改相关数据源，而不用更改访问内容提供器地应用中地代码。 SyncAdapters，Loaders，CursorAdapter需要通过contetn provider 访问数据。 向其他应用开发数据源，使他们能够访问，使用修改你的数据源。 用途： 提取基础数据，安全高效地跨应用边界分享数据 轻松地切换数据源，而且更便于他人管理UI层代码 向小部件发送数据，或从更新的应用返回搜索结果 有效地与服务器同步，并在UI层实时更新 ContentResolverContentResolver使应用与正确的ContentProvider沟通。 Cursorcursor是一种迭代器，使程序能够以表格的形式访问相关数据。 SimpleExample：12345678910111213141516171819// Get the TextView which will be populated with the Dictionary ContentProvider data. ListView dictListView = (ListView) findViewById(R.id.dictionary_list_view); // Get the ContentResolver which will send a message to the ContentProvider. ContentResolver resolver = getContentResolver(); // Get a Cursor containing all of the rows in the Words table. Cursor cursor = resolver.query(UserDictionary.Words.CONTENT_URI, null, null, null, null); // Set the Adapter to fill the standard two_line_list_item layout with data from the Cursor. SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.two_line_list_item, cursor, COLUMNS_TO_BE_BOUND, LAYOUT_ITEMS_TO_FILL, 0); // Attach the adapter to the ListView. dictListView.setAdapter(adapter);]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
