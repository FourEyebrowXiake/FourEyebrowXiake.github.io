webpackJsonp([0x81b8806e4260],{"./node_modules/json-loader/index.js!./.cache/json/index.json":function(n,s){n.exports={data:{site:{siteMetadata:{title:"四条眉毛的博客",description:"I'm Lin Jin , a web developer and a travel enthusiasts. My target is to write clean and efficient code, to solve poblems on the web and to learn something more. ",author:"Lin Jin"}},remark:{posts:[{post:{html:'<h1>ScopeChains</h1>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 57.51412429378531%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAB30lEQVQoz52SyXLaQBRF+f+fSFbOH6RSlZW32WQDBQGEkQQSrbHVs9TYN68bjA3ZZXFLPajPu2+Yjd7BDQbSCEincH7zUeF8f9wjK1KUdYnpPKLpR/z6LeBf/e2/R82ct1BGQo+GfpwuepsiYLFekOYR6CaLn88SX78puruH+DvgZCBOAzjrMQgJoS8uA3D+Z47Nfo0238KrnqAeUklUDcOJgtRdBUZrVmQxoyvQwkqNuhUYKO33i+CUK46qYzCjxsTyyzll1Pc1dvkOKZUkp4DT6/jh0FKqQcqp6CqAPqdjKWAEDQ08BQzrtjkhSZbYkZJHoHEU3YywRw1eaVQ9j/UK8KBwH1wHvbtshxYZgfLdKjbuDqivneWdxqkTEOa6Fz3Vb4PNyzo+UlZizDYQNBEdpZzRXZolyNLtv8DoSJMLR06vNQyOFpsFltslVskqluX7D4YvTx2mUNPgPnzprafG3gG9HeE6C65DvaYbMCEHQQd2iPumpy6bjzGxV9Dnus+UVbCKmiJdjHob7LOLoKCyLqDtJZPQpOA2rB8bGIEVjUzfjnhhLUphkFEdh+l8cUAPy6qIM8fqEwp2RMsb+hY4lAdULYtn8Z7mMWQ7a3iLJN2hpIO0zsEljxr+U38BWIqW2A7UvvkAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="&#x7B2C;&#x4E00;&#x9898;" title="" src="/static/89b350957e8f4e340df808d096d73676-245fd.png" srcset="/static/89b350957e8f4e340df808d096d73676-7aee9.png 188w,\n/static/89b350957e8f4e340df808d096d73676-2014b.png 375w,\n/static/89b350957e8f4e340df808d096d73676-245fd.png 750w,\n/static/89b350957e8f4e340df808d096d73676-116ee.png 885w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  \n<figcaption>&#x7B2C;&#x4E00;&#x9898;</figcaption></body></html>\n<p>图片描述的是 myG()执行后，执行环境中还保留的作用域链。因为闭包的缘故，只有 g()的作用域被回收了。</p>\n<p>当时看到结果时，对 g()的作用域被回收这个现象还是有疑惑的。因为，我心中的闭包是函数和其绑定的周边状态（词法环境）的组合。而对“周边状态”的范围，我没有清楚的界限。我认为 g 函数中的变量 e 会被保留。</p>\n<p>后来改了一下代码：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\te<span class="token operator">++</span><span class="token punctuation">;</span>\n\t<span class="token keyword">return</span> e<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>运行了下代码发现e的值并不像d一样会叠加。这才发现自己错了。</p>\n<p>事后，想了想，认为 g 的作用域肯定是要被回收的，毕竟有没有人引用它的作用域。</p>\n<hr>\n<h1>EventLoop</h1>\n<p>对事件循环的讲解，我并没有疑问。只是第一次看到有人把 Js 执行流程用动画表现出来，感觉很赏心悦目。</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 620px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 72.09677419354838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAAwElEQVQ4y82Syw6CMBBF+f8/4xPcKSagLkBa+popXGsDESIaAU1cnKTtNKe30yZOnWBkDqsKsD6DeoaxbYoIj9bHjPfKMkPi2EI7BUMavuMJ5B20DTX3XJtDKoGEWvdyA7X0kWgq9O+E7tvCv0jY/kDI4WoRXYLZPOYLiULu+8TegPYp3CFdlGq2h8MJdNmBRL46oVA1Eksmmhst4wfmjlYnrEQ1TbiVqwxCGx6hDlGlDimN3CSMCQfRVu79O+YZbpIPSjHFTuftAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="EventLoop" title="" src="/static/0d29efdbaae8cc1a85cdcbb9a90c3d24-3bb03.png" srcset="/static/0d29efdbaae8cc1a85cdcbb9a90c3d24-fc894.png 188w,\n/static/0d29efdbaae8cc1a85cdcbb9a90c3d24-d0f89.png 375w,\n/static/0d29efdbaae8cc1a85cdcbb9a90c3d24-3bb03.png 620w" sizes="(max-width: 620px) 100vw, 620px">\n    </span>\n  </span>\n  \n<figcaption>EventLoop</figcaption></body></html>\n<hr>\n<h1>Vedio</h1>\n<div>\n          <div\n            class="gatsby-resp-iframe-wrapper"\n            style="padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden;margin-bottom: 1.0725rem"\n          >\n            <html><head></head><body><iframe src="https://www.youtube.com/embed/QyUFheng6J0" frameborder="0" allowfullscreen style="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          "></iframe></body></html>\n          </div>\n          </div>',frontmatter:{layout:"post",title:"《Arindam Paul - JavaScript VM internals, EventLoop, Async and ScopeChains》观后感",path:"/Arindam Paul's Speech/",categories:["JavaScript"],description:"自己闷着头看书学习，不和别人交流是不行的。尤其是对到现在还没找到工作的我，感触颇深。所以，花时间看了这个演讲。英文比较差，看了好几篇，理解可能还有错误，希望你别太相信我的话。<!--more-->",date:"2017/10/10"}}},{post:{html:'<h1>说点历史</h1>\n<p>了解 JavaScript 的都知道，除了几个简单的数据类型，剩下的所有数据类型在 Javascript 中都是对象。之所以会这样，是因为 Js 诞生于面向对象思想最兴盛的时期。Js 之父 Brendan Eich 无疑受到了影响。</p>\n<p>面向对象的思想如此的火热，以至于出现了一些狂热的言论，如没用使用面向对象思想的程序都是过时的设计。这些言论当然是荒谬的，但不得不承认面向对象的变革推动了一些概念的流行。其中最重要的概念就是<strong>封装</strong>（将内部复杂性与外部接口切割开来)，而对象正是这一概念最鲜明的体现。</p>\n<p>有了封装，才有了多态和继承等概念，可见其重要性。</p>\n<!-- more -->\n<h1>封装</h1>\n<p>对象就像一个坚硬的外壳，它隐藏了其内部的复杂性，并提供给我们一些旋钮和接口（如方法）作为操作对象的接口。这一想法就是封装的具体体现。</p>\n<h1>多态</h1>\n<p>接口的多种不同的实现方法即为多态。</p>\n<p>JavaScript 中多态是通过<strong>组合</strong>和<strong>虚函数</strong>来实现的。构造函数接受函数作为参数，来自定义自己的接口。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token comment" spellcheck="true">//父对象</span>\n<span class="token keyword">function</span> <span class="token function">TextCell</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nTextCell<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>minWidth <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> line<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> line<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nTextCell<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>minHeight <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nTextCell<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>draw <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> height<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> line <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">;</span>\n    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>line <span class="token operator">+</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> width <span class="token operator">-</span> line<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> result<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">//子对象</span>\n<span class="token keyword">function</span> <span class="token function">UnderlinedCell</span><span class="token punctuation">(</span>inner<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>inner <span class="token operator">=</span> inner<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nUnderlinedCell<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>minWidth <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">minWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nUnderlinedCell<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>minHeight <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">minHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nUnderlinedCell<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>draw <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> underlinedCell <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnderlinedCell</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TextCell</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>如上，通过把 TextCell 对象传入 UnderlinedCell 构造函数进行组合。而像 minHeight、 minWidth 这类在父类和子类有不同实现的函数为虚函数。所以说 Js 中多态的实现靠组合和虚函数。</p>\n<h2>继承</h2>\n<p>当你像构造出与当前类型相似的类型时，可以通过继承来实现。</p>\n<p>Js 中的继承有多种实现，这里只介绍寄生组合式继承这一种。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token comment" spellcheck="true">// Shape - superclass</span>\n<span class="token keyword">function</span> <span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment" spellcheck="true">// superclass method</span>\nShape<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>move <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> x<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> y<span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">\'Shape moved.\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// Rectangle - subclass</span>\n<span class="token keyword">function</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  Shape<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// call super constructor.</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment" spellcheck="true">// subclass extends superclass</span>\nRectangle<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Shape<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\nRectangle<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Rectangle<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// for rect instanceof Rectangle === true</span>\n\n<span class="token keyword">var</span> rect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Is rect an instance of Rectangle?\'</span><span class="token punctuation">,</span> rect <span class="token keyword">instanceof</span> <span class="token class-name">Rectangle</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Is rect an instance of Shape?\'</span><span class="token punctuation">,</span> rect <span class="token keyword">instanceof</span> <span class="token class-name">Shape</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>\nrect<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Outputs, \'Shape moved.\'</span>\n</code></pre>\n      </div>\n<p>其实呢，我们天天在用的 array、object 的继承关系和上面的代码如出一辙，看下图，Shape 相当于 Object，Rectangle 相当 Array:</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 89.22470433639947%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAAB+ElEQVQ4y6VU2Y7aQBDk/z8lWQUeAvsAIjwgENhcZhdsYgPGYO4bAX6A2qlGRnspAtJSqwfTU1Pd1TORIDii02ljNpvhX3Y8HtFut+H7Q7iuq/Z0cDgcv+RFttstGo0GWq0WRqMRJpMJ5vM5FosFVqvVNZG/Cfjy8op+vw9L5fd6Pcmhc9/5fEZkPB4jHv+NWCyKxPMzstmseDKZRK1Ww2azEa/X6zCbTVQqVQwGA9i2DdM0MR5PQAyuT6cTIkTl4jvnf6GRjaEOKJdKGKpKyLZaraoDKlKdYRgXQNxoLFPTNAGg53I5ieG3fD5/AWT9PP09m+8sUKJYVgsdxaylou20RajhcCgxCIJLD6kuE9kXisHm8hsP2u12V8Dlcik57BXZ2rYjOVT8gyiNxiuiv6J4+vkDfzIZESSVSiGj1uzTZ1FKqoeDgS9AJEBxCGZZ1uOicLzIkFNQLpdl7CjQXaIQUNc11Y65lOgoQF3XoRU1NFUbCH4XoOd5woKl04vFokQCMRYKhfsAmUyRPjuZM+73+4sotwIe1AaOjOf1RazQ1uv1x7t8KyDvMtU0jDqm06kIw/Ghv39Y7hLlr7piHGTeXY5Ns2mKQN1u9zFADnb4urhuVx6K/wIkK6odgpim9Tig7/uIRWOIJxIyMul0Wh4Irh3Huea9AbSMUGPwWdbMAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="Array" title="" src="/static/a8c122fad8f0568f52f8b285f8ca4393-245fd.png" srcset="/static/a8c122fad8f0568f52f8b285f8ca4393-7aee9.png 188w,\n/static/a8c122fad8f0568f52f8b285f8ca4393-2014b.png 375w,\n/static/a8c122fad8f0568f52f8b285f8ca4393-245fd.png 750w,\n/static/a8c122fad8f0568f52f8b285f8ca4393-40330.png 761w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  \n<figcaption>Array&#x548C;Object&#x7684;&#x7EE7;&#x627F;&#x5173;&#x7CFB;</figcaption></body></html>',frontmatter:{layout:"post",title:"Javascript中的多态和继承",path:"/Javascript中的多态和继承/",categories:["JavaScript"],description:"从面向对象到多态和继承。<!--more-->",date:"2017/09/22"}}},{post:{html:'<h1>前言</h1>\n<p>在 JavaScript 的世界中，所有代码都是单线程执行的。</p>\n<p>由于这个“缺陷”，导致 JavaScript 的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数来实现。常见的例子如 AJAX，就是典型的异步操作：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>request<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token function">success</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token function">fail</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>把回调函数 success(request.responseText)和 fail(request.status)写到一个 AJAX 操作里很正常，但是不好看，而且不利于代码复用。所以，为了使代码更优雅。出现了这样的写法：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> ajax <span class="token operator">=</span> <span class="token function">ajaxGet</span><span class="token punctuation">(</span><span class="token string">\'http://...\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    ajax<span class="token punctuation">.</span><span class="token function">ifSuccess</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">ifFail</span><span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>这种链式写法的好处，不单单是优雅。它使得执行代码和处理结果的代码清晰的分离了。</p>\n<h1>Promise基础介绍</h1>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。</p>\n<h2>常见用法</h2>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment" spellcheck="true">// ... some code</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment" spellcheck="true">/* 异步操作成功 */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment" spellcheck="true">// success</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment" spellcheck="true">// failure</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>再来张图：\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 512px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 54.6875%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABBklEQVQoz41R0XKDIBD0/z8s9il10vQhOgPpqChUjYAo+NKuOdvp1KTNjuMccHvsLtHHA5jneRgG55y1FoW9AkX0CFlKJUR1OLwkSbLbxYyxy6XH/kL2PrgNQghaG8a4lLIoy2matkMXsjEGwkBAh/cePyybpgENR9RHsn9hIXddp9Q7uqGtrmshRN/3pRBKKSKHMMOjMRYfjrTW8LyScRtNogOqsYlVmmYYcTqlVVUdj6/7/XMcPxVFAWmrbIBxjjzO57dxHLfeyNENz+SWAMHw+b2k8atndwMRbuOc53mOYEGG/2vCCrEhpL+fMEIkeJW2bbMs+3kVqf2H3LStuwP99U738AmXpniB7EmHqQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="promise&#x4ECB;&#x7ECD;" title="" src="/static/086bad039172d23fba9e7ed60beafb1a-bd09a.png" srcset="/static/086bad039172d23fba9e7ed60beafb1a-f7cda.png 188w,\n/static/086bad039172d23fba9e7ed60beafb1a-34ae2.png 375w,\n/static/086bad039172d23fba9e7ed60beafb1a-bd09a.png 512w" sizes="(max-width: 512px) 100vw, 512px">\n    </span>\n  </span>\n  </body></html></p>\n<figcaption>promise介绍</figcaption>\n<p>看图说话：</p>\n<ol>\n<li>Promise 构造方法接受一个方法作为参数，该方法传入两个参数，resolve 和 reject。这两个参数都是函数。</li>\n<li>resolve 用来将 Promise 对象的状态置为成功，并将异步操作结果 value 作为参数传给成功回调函数。</li>\n<li>reject 用来将 Promise 对象的状态置为失败，并将异步操作错误 error 作为参数传给失败回调函数。</li>\n<li>then 方法绑定两个回调函数，第一个用来处理 Promise 成功状态，第二个用来处理 Promise 失败状态。</li>\n</ol>\n<h2>Promise状态</h2>\n<p>因为 Promise 是用来异步操作的，所以它他有三种状态：</p>\n<ul>\n<li>Pending（执行中）</li>\n<li>Fulfilled (已完成)</li>\n<li>Rejectd（失败）。\n后两者对应着处理结果。</li>\n</ul>\n<p>状态间的具体关系：\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 532px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 53.19548872180451%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAAA3ElEQVQoz7WSyQ6DMAxE8/+fxpUThCwkhEXsCCEOSC52BS2HUorUw8gixC/jZNgwDPBJWmvI83yXMQaqqoKzHnb2EyFFUYC1FuI4hnme6ZDbwM2hc44qgsuyvA/cFEURXNn3P2DbtsA5B6XUelca9HpfziUgpaI13/epWhODEJJG5xGHMHz2JElyBNZ1fVj8VQg9ADEOQRDcBnqe9wKiM4yEEIJeM03TS5C+78kZ9qAZrMhh0zTtH+M4Xh4d9y/LQtNlWUZ5RbGmaaDrOhI+zrfgbsI8opH3fiklPADFfj9ZvPoxlAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="promise&#x72B6;&#x6001;" title="" src="/static/1809c568d70e5d57b656ef46a106f2bc-76933.png" srcset="/static/1809c568d70e5d57b656ef46a106f2bc-909ff.png 188w,\n/static/1809c568d70e5d57b656ef46a106f2bc-017fe.png 375w,\n/static/1809c568d70e5d57b656ef46a106f2bc-76933.png 532w" sizes="(max-width: 532px) 100vw, 532px">\n    </span>\n  </span>\n  </body></html></p>\n<figcaption>promise状态</figcaption>\n<p>如上图所示，Promise 对象有两个特点：</p>\n<ol>\n<li>\n<p>对象状态只由异步操作结果决定。resolve 方法会使 Promise 对象由 pendding 状态变为 fulfilled 状态；reject 方法或者异常会使得 Promise 对象由 pendding 状态变为 rejected 状态。Promise 状态变化只有上图这两条路径。</p>\n</li>\n<li>\n<p>对象状态一旦改变，任何时候都能得到这个结果。即状态一旦进入 fulfilled 或者 rejected，promise 便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。</p>\n</li>\n</ol>\n<h1>串行执行</h1>\n<p>通常要串行执行异步任务们，不用 Promise 需要写一层一层的嵌套代码。有了 Promise，我们只需要简单地写：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>job1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>handleError<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>可以这样写的原因是 then 返回的是 promise 的实例。这种写法也叫级联。</p>\n<p>一个详细的例子：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment" spellcheck="true">// 0.5秒后返回input*input的计算结果:</span>\n<span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'calculating \'</span> <span class="token operator">+</span> input <span class="token operator">+</span> <span class="token string">\' x \'</span> <span class="token operator">+</span> input <span class="token operator">+</span> <span class="token string">\'...\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> input <span class="token operator">*</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment" spellcheck="true">// 0.5秒后返回input+input的计算结果:</span>\n<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'calculating \'</span> <span class="token operator">+</span> input <span class="token operator">+</span> <span class="token string">\' + \'</span> <span class="token operator">+</span> input <span class="token operator">+</span> <span class="token string">\'...\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> input <span class="token operator">+</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'start new Promise...\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\np<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>multiply<span class="token punctuation">)</span>\n <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>\n <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Got value: \'</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<h1>并行执行</h1>\n<p>除了串行执行若干异步任务外，Promise 还可以并行执行异步任务。</p>\n<p>试想一个页面聊天系统，我们需要从两个不同的 URL 分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用 Promise.all()实现如下：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">\'P1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token string">\'P2\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// 同时执行p1和p2，并在它们都完成后执行then:</span>\nPromise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>results<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得一个Array: [\'P1\', \'P2\']</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>那 all()的具体实现是怎样的呢？</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>succeed<span class="token punctuation">,</span> fail<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pending <span class="token operator">=</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        results<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>\n        pending <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n          <span class="token function">succeed</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">fail</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>promises<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n      <span class="token function">succeed</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>参考链接：</p>\n<ul>\n<li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000">Promise</a></li>\n</ul>',
frontmatter:{layout:"post",title:"上手Promise",path:"/上手Promise/",categories:["JavaScript"],description:"感觉Promise的强大之处在于把执行的代码和处理结果的代码清晰的分离了。<!--more-->",date:"2017/09/10"}}},{post:{html:'<h1>什么是人工智能？</h1>\n<p>专家观点：尚未统一。作者的定义是，人工智能是“用人工方法制作的类人智能”，类人智能指的是具有“发现和觉察功能”的计算机，即能够从数据中生成特征量，并对相关现象进行模型化处理的计算机。</p>\n<h2>人工智能的发展历史</h2>\n<p>人工智能的研究是从以“推理”为重点到以“知识”为重点，再到以“学习”为重点，一条自然、清晰的脉络。</p>\n<!-- more -->\n<h2>第一次人工智能狂潮的局限（20世纪60年代）</h2>\n<p>计算机只能解决所谓的“玩具问题”。求解迷宫问题，挑战国际象棋及将棋，这些都只需要在明确定义好的规则中考虑下一步如何走起即可，然而，现实生活中的问题却要复杂得多。</p>\n<h2>第二次人工智能狂潮的局限（20世纪80年代末）</h2>\n<h4>永无穷尽的知识</h4>\n<p>Example:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>He saw a woman in the garden with a telescope.</code></pre>\n      </div>\n<p>理解这句话，需要一般性的常识。而计算机要处理一般性的常识，就需要掌握人类所拥有的，永运也无法写尽的海量知识，这是极其困难的。因为\n，同样的事情在所有的各种各样的场合皆会发生。</p>\n<p>它用望眼镜看到一个女人在花园呢？ 还是他在公园用望眼镜看到一个女人？</p>\n<h4>框架问题</h4>\n<p>框架问题，就是执行某项任务时“仅仅提取出与它相关的知识并对其加以运用”，这对人类来说简单的事，但对计算机来说是困难无比的。</p>\n<blockquote>\n<p><a href="http://sourcedb.cas.cn/sourcedb_scr_cas/zwqkk/kxwhzl/kxzx/200912/t20091226_2718491.html">认识框架问题</a></p>\n</blockquote>\n<h4>符号接地问题</h4>\n<p>是否能将符号（词语,语言）与它所表示的意义连接起来。</p>\n<blockquote>\n<p>日本在1982年启动了名为“第五代计算机”的国家级项目，从1982年开始前后跨越了10年，总共投入了570亿日元。尽管没有实现预定目标，但是它聚集了人工智能研究的优秀人才，还吸引了众多的海外知名专家，并由此建立了相关的人才联系网络。</p>\n</blockquote>\n<!-- more -->\n<h2>第三次人工智能狂潮（机器学习，深度学习）</h2>\n<h3>机器学习</h3>\n<p>机器学习，一种实现人工智能的方法。</p>\n<p>它是使用算法来分析数据的实践、学习，然后对真实的事件作出决定或预测。而不是用一组特定的指令生成的硬编码软件程序来解决特定任务。机器是通过使用大量的数据和算法来「训练」，这样就给了它学习如何执行任务的能力。</p>\n<h4>机器学习的难点</h4>\n<p>机器学习最关键的地方是如何把一个把原始数据转变成特征量。这些特征量可以很好的描述这些数据，并且利用它们建立的模型在未知数据上的表现性能可以达到最优（或者接近最佳性能）。从数学的角度来看，特征工程就是人工地去设计输入变量 X。</p>\n<p>可惜的是特征量的设计必须由人来做。</p>\n<blockquote>\n<p>特征量，指的是机器学习在输入时所使用的变量，其值是对对象特征的定量表示。</p>\n</blockquote>\n<h4>深度学习</h4>\n<p>Wiki 上的解释：</p>\n<blockquote>\n<p>深度学习（英语：deep learning）是机器学习拉出的分支，它试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。</p>\n</blockquote>\n<p>深度学习， 一种实现机器学习的技术。它能自己产生特征量。其实回过头看，人工智能的发展其实是给予机器越来越抽象的基本信息。</p>\n<p>至于深度学习的实现过程，我其实也是模模糊糊。等有深入了解后，再来改进这篇文章。</p>',frontmatter:{layout:"post",title:"《人工智能狂潮》摘记",path:"/人工智能狂潮摘记/",categories:["探索未来"],description:"人工智能，机器学习，深度学习，这三个东西到底是什么？它们之间有什么联系？<!--more-->",date:"2017/05/23"}}},{post:{html:'<h1>序</h1>\n<p>首先你在浏览器里输入网址，然后按下 Enter 键，之后浏览器就会开始查找 IP。它会先从浏览器的缓存里寻找相应的 IP。如果找不到，它会依次从系统缓存，路由器缓存，ISP DNS 缓存中寻找 IP。如果还是找不到的话，那只能从根域名开始，递归的往下搜索，比如从.com 到 Facebook.com。找到 IP 后，就会向服务器发起 HTTP 请求，然后服务器处理请求，可能返回一个 HTML 响应。一直到这一步，只能算是问题的一部分。为什么这么说呢？　你完全可以把上面的文字添加到“输入 url 到加载完页面发生了什么”后面，组成一个简单很多的问题。文章接下来的部分，就是在回答这个更简单的问题。现在的我还不能面面俱到，只能选熟悉的地方回答。</p>\n<h1>关键渲染路径</h1>\n<p>浏览器接收到服务器返回的 HTML、CSS 和 JavaScript 字节数据并对其进行解析和转变成像素的渲染过程被称为关键渲染路径。通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。优化关键渲染路径是指优先显示与当前用户操作有关的内容。</p>\n<p>浏览器在渲染页面时，需要知道页面结构和样式。所以，浏览器会先构建 DOM 树和 CSSOM 树，像是画蓝图一样。</p>\n<p>DOM 树全称为 Document Object Model 文档对象模型，它是 HTML 和 XML 文档的编程接口，提供了对文档的结构化表示，并定义了一种可以使程序对该结构进行访问的方式（比如 JavaScript 就是通过 DOM 来操作结构、样式和内容）。DOM 将文档解析为一个由节点和对象组成的集合，可以说一个 Web 页面其实就是一个 DOM。</p>\n<p>CSSOM 树全称为 Cascading Style Sheets Object Model 层叠样式表对象模型，它与 DOM 树的含义相差不大，只不过它是 CSS 的对象集合。</p>\n<h2>构建DOM</h2>\n<p>浏览器获得 HTML 文件后会经过一个流程将数据解析为 DOM 树：</p>\n<html><head></head><body><figcaption>&#x5B57;&#x8282; &#x2192; &#x5B57;&#x7B26; &#x2192; &#x4EE4;&#x724C; &#x2192; &#x8282;&#x70B9; &#x2192; &#x5BF9;&#x8C61;&#x6A21;&#x578B;</figcaption>\n\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 55.38735529830811%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACZUlEQVQoz2MQXZQ4TWBB3B6BWdF7BJcm7pHIdNFjYGCQAWJpIFaE0nxAzA/EvFCaB4nNC8WcDCCw4NDhsPmHj+TO3be/dOHRY7mzNm0R3bFjB+eyZcu4YBjGB9HobGR84sQJNobDVx6nbz9+tXHZlgMdJ269auybvkDB3NxczsjISNHe3l7K1NRU3tjYWAHEB7FBtIGBgRKIBqkDYZiBN27cYGU4dPnR2gMXH97aefL67WM3nt9avvdGwcLtlycuP/SkdtHOqxOX7b0xcd+FN/XLDzyoXbzr6sRVR1+0zN18fuLKA3cmLt77oAmkZsOZD00rjzxrOnPzXSzDuzNp6a9OJDXe3hPf+fVSWuPFfdXatw7m1z8402J/72SD540DhWXrtm4XuHmotPDmkeqwWye79G4cKCi/emKq4uPT1ZlAnH73dJfZjf25bQ9ONzoyPDycFvb4cGrulR1Jpc+OpeWe3FEvcetkh/3xA3Olzx+ZqnLndKf9/sOnOG+c6La6eGSC9jGg+O3jjV5HDq0SvnR0gj4Q650+PFvm6rFuy30H1goxfDqfNvPTueSDz4/GH/xxJe3gvYMZCgxYQPCK/ywXj3Rk3DhcsXLRrtOsDKSCq0cas28dLlkUPPm/sEvXf073/v8sV4Bit4+ULoqY9InXb95/JqINu3OsvPHaoaquB6frfe8dK16zautakXsnaybeONHW7DXtPwdIjdfU/+xXD9cufni6Opckl165/ynu5KWHay5f3JF87WDp9otXzhYePHVr46kbHxyAFs++d6Iql4EccOry4w3Hzt3ZdOziow586gDRzlUjJVK7HAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="&#x5B57;&#x8282; &#x2192; &#x5B57;&#x7B26; &#x2192; &#x4EE4;&#x724C; &#x2192; &#x8282;&#x70B9; &#x2192; &#x5BF9;&#x8C61;&#x6A21;&#x578B;" title="" src="/static/cc3a2a29937364a40360717171744b03-245fd.png" srcset="/static/cc3a2a29937364a40360717171744b03-7aee9.png 188w,\n/static/cc3a2a29937364a40360717171744b03-2014b.png 375w,\n/static/cc3a2a29937364a40360717171744b03-245fd.png 750w,\n/static/cc3a2a29937364a40360717171744b03-f5424.png 1123w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  </body></html>\n<ol>\n<li>\n<p>转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</p>\n</li>\n<li>\n<p>令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“<html>”、“<body>”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</p>\n</li>\n<li>\n<p>词法分析： 发出的令牌转换成定义其属性和规则的“对象”。</p>\n</li>\n<li>\n<p>DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。</p>\n</li>\n</ol>\n<p>整个流程的最终输出是我们这个简单页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。</p>\n<h2>构建CSSOM</h2>\n<p>在浏览器构建 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并得到以下内容：</p>\n<div class="gatsby-highlight">\n      <pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 16px <span class="token punctuation">}</span>\n<span class="token selector">p</span> <span class="token punctuation">{</span> <span class="token property">font-weight</span><span class="token punctuation">:</span> bold <span class="token punctuation">}</span>\n<span class="token selector">span</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span>\n<span class="token selector">p span</span> <span class="token punctuation">{</span> <span class="token property">display</span><span class="token punctuation">:</span> none <span class="token punctuation">}</span>\n<span class="token selector">img</span> <span class="token punctuation">{</span> <span class="token property">float</span><span class="token punctuation">:</span> right <span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>与构建 DOM 时候一样，会依次产生字节，字符，令牌，节点，css 对象模型：\n<html><head></head><body></body></html></p>\n<p>将 cssom 和 dom 比较，你会发现 cssom 是基于 dom 构建的。实际情况下，浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕,所以说 css 被视为阻塞渲染的资源。</p>\n<blockquote>\n<p><a href="https://segmentfault.com/q/1010000000713509">浏览器为什么要从右向左匹配 CSS 选择器</a></p>\n</blockquote>\n<h2>构建渲染树</h2>\n<p>在构建了 DOM 树和 CSSOM 树之后，浏览器只是拥有了两个互相独立的对象集合，DOM 树描述了文档的结构与内容，CSSOM 树则描述了对文档应用的样式规则，想要渲染出页面，就需要将 DOM 树与 CSSOM 树结合在一起，这就是渲染树。</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 46.69565217391305%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB60lEQVQoz2NgQABRIGYBMW6c7LS+ebhk0eFDC3gZUIEIEAsxEAJXD1XWnjvQUOTW+5/TueM/57EDk92uHChdPGHNKbjmo9e/qp6/+mD/qYv3Vu679NX58uGG/MsHqzud2/9yes/4zwo37PaxiuLLh2oarx2u7r5zoib1xsn2iOvHmuaADPad859p++7FhnePly2/fLxHDqTec8p/1tvHa9uvn2jL3bV7vtaNQ8Wrjx6YanzpYM2qu6ca7eAGb7/0X+j05Udrzl1/nHH5QMXyK5d25B48fXvV2QtHk+4eLV5y5vwx18tXb706df7mq4sXD1RdOVC+8uqteyvOXrr94NS1lyuvXL/77OzluxcwvH/swqOC4+fvrDh05l4PsviB1/+ZD1//JTf16H/W89ce3zt14eaD01efTw2e/p8ZJO/f95cdrLCkpIS5sLCQgxDOzc3lhrEzc4o5cajhRI9BMSAG23Tp9qvZV++82HL6+uuaqw8+2929/2jLrcefDRlIBZsuP5Pef+HQlT1n91/Zcu5i1oMzDaUPTlVuXr33MNj22yfqJgH5i4g2cNvD/6wHb98xXXv+ufTFO++mnr32dP25W+9bj5y9s+P8nU92j05V9Nw9Xr5o97Wb6QcuHr575NqJu5svP1WA6QcAkmsdvh0WJ48AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="&#x6E32;&#x67D3;&#x6811;" title="" src="/static/b0bc0b83c73cf0de7cc86ae8c05027d9-245fd.png" srcset="/static/b0bc0b83c73cf0de7cc86ae8c05027d9-7aee9.png 188w,\n/static/b0bc0b83c73cf0de7cc86ae8c05027d9-2014b.png 375w,\n/static/b0bc0b83c73cf0de7cc86ae8c05027d9-245fd.png 750w,\n/static/b0bc0b83c73cf0de7cc86ae8c05027d9-a0f71.png 1125w,\n/static/b0bc0b83c73cf0de7cc86ae8c05027d9-44b35.png 1150w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  </body></html>\n<p>为构建渲染树，浏览器大体上完成了下列工作：</p>\n<ol>\n<li>\n<p>从 DOM 树的根节点开始遍历每个可见节点。</p>\n<ul>\n<li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li>\n<li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点不会出现在渲染树中，因为有一个显式规则在该节点上设置了“display: none”属性。</li>\n</ul>\n</li>\n<li>\n<p>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。</p>\n</li>\n<li>\n<p>发射可见节点，连同其内容和计算的样式。</p>\n</li>\n</ol>\n<p>渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则需要计算每个节点在窗口内的确切位置与大小，也就是布局阶段。</p>\n<h2>布局</h2>\n<p>布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置。布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值。</p>\n<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。</p>\n<h2>总结</h2>\n<p>下面简要概述了浏览器完成的步骤：</p>\n<ol>\n<li>处理 HTML 标记并构建 DOM 树。</li>\n<li>处理 CSS 标记并构建 CSSOM 树。</li>\n<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>\n<li>根据渲染树来布局，以计算每个节点的几何信息。</li>\n<li>将各个节点绘制到屏幕上。</li>\n</ol>\n<p>优化关键渲染路径_就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。具体怎么优化，请看下一节。</p>\n<p>以上就是浏览器从获得文件，到初次加载页面的全部信息。</p>\n<h1>优化</h1>\n<p>通过一张图来说优化方法。</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 49.61325966850828%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABt0lEQVQoz42SaVPCMBCG/f+/yA8eWGRAwVJnQAcCvUS5WuiV9CD0dZMqI/rFndnpJtk82X23F1JK/MdzUWG74li9cwiKeVZC8ApJXCKOCkS7QuddgIxNp2BsiiAI4HkefN/DdrvFcrmEbds6scgl4n1FYIl9WCIiV7Ha//CFPqvrugEuHAevbQNr38ek08F0OIRjPsEeDGCPRjgejxrishTsJaVKCyRRhXCT490TVF1FDIHVIm+Aiqz8SJWoryxL1ASRQui1smBdYuFy7QoYE+TNUbASDssIzHWeBrapuk7nHm3DoHZ9ONTmiCprtW4xoCq73S4M4x6maZE0DK7rwp/NkLAZUpJIP9q82wBTfcjACRYTKJlMkFFiQTpWcQxBWpa7nV5nBFN54s1HOrf12XcXJ6C6dMgyFHRJFgUOSfKVVJ/k+HkJjU6Qea7zT+V9A1uXl2jf3uDu6grufI45Tb3X6+Gh18WQBvRAcev6GhbFM+rGoSGqPyDfbJCvN2fvaGDw2EdKuu2fLcQvY0TjMcJ+H6FpYm9ZCAdP2JGWav834LedTVnZgfNm/dVGEzem2jtrvf4L/AQHYfRKPro1oQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="&#x4F18;&#x5316;" title="" src="/static/654bc53d055ea9fd0a726f480f4e72e9-245fd.png" srcset="/static/654bc53d055ea9fd0a726f480f4e72e9-7aee9.png 188w,\n/static/654bc53d055ea9fd0a726f480f4e72e9-2014b.png 375w,\n/static/654bc53d055ea9fd0a726f480f4e72e9-245fd.png 750w,\n/static/654bc53d055ea9fd0a726f480f4e72e9-728b7.png 905w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  </body></html>\n<h3>Minify,Compress, Cache</h3>\n<p><strong>Minify</strong>指的是资源最小化，具体包含预处理和环境特定优化两部分。</p>\n<p>在计算机科学中，预处理器是程序中处理输入数据，产生能用来输入到其他程序的数据的程序。 输出被称为输入数据预处理过的形式，常用在之后的程序比如编译器中。在网站中的表现形式要差不多。网页中的 html，css 和 JavaScript 等根据不同的规则构成有效的内容元素。例如：</p>\n<ul>\n<li>\n<p>代码注释是开发者最好的朋友，但浏览器不需要看到它们！　直接删除 CSS (/* … */)、HTML (<!-- … -->) 和 JavaScript (// …) 注释可显著减小网页的总大小。</p>\n</li>\n<li>\n<p>“智能”CSS 压缩程序会注意到采用低效率的方式为“.awesome-container”定义规则，它会将两个声明折叠为一个而不影响任何其他样式，从而节省更多字节。</p>\n</li>\n<li>\n<p>空白（空格和制表符）能够在 HTML、CSS 和 JavaScript 中给开发者提供方便。可以增加一个压缩程序来去掉所有制表符和空格。</p>\n</li>\n</ul>\n<p>另外还会根据特定的场合进行优化。简单的说就是只给用户需要的。</p>\n<p><strong>Compress</strong>是指压缩文本，如通过 gzip。GZIP 是一种可以作用于任何字节流的通用压缩程序。它会在后台记忆一些之前看到的内容，并尝试以高效方式查找并替换重复的数据片段</p>\n<p><strong>Cache</strong>指的是 Http 缓存。</p>\n<h3>Minimize use of render blocking resource</h3>\n<p>意思应该很明确。通过 media query 来按需加载和內联 css 来减少资源。</p>\n<h3>Minimize use of parser blocking resource</h3>\n<p>有关 script,script defer 和 script async 的不同，可以看下图：</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 496px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.25544267053701%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdwRRH//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEAAwAAAAAAAAAAAAAAAAABABAx/9oACAEBAAE/ITY1/9oADAMBAAIAAwAAABCIL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQACAwAAAAAAAAAAAAAAAAEAEBEhcf/aAAgBAQABPxBadY3JX//Z&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="js&#x5F02;&#x6B65;" title="" src="/static/244a0c3246f534e96ce88124e3978261-ff284.jpg" srcset="/static/244a0c3246f534e96ce88124e3978261-02be4.jpg 188w,\n/static/244a0c3246f534e96ce88124e3978261-4f2c6.jpg 375w,\n/static/244a0c3246f534e96ce88124e3978261-ff284.jpg 689w" sizes="(max-width: 496px) 100vw, 496px">\n    </span>\n  </span>\n  </body></html>',frontmatter:{layout:"post",title:"输入url到加载完页面发生了什么?",path:"/从输入URL到页面加载发生了什么/",categories:["前端"],description:"看过不少人的回答，有的牛人竟然从数字逻辑开讲，真是让人惊叹计算机科学的伟大<!--more-->",date:"2017/10/15"}}},{post:{html:'<h1>动态规划的基本思想</h1>\n<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。</p>\n<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。在实际情况中，可以用一个表记录所有已解的子问题的答案。</p>\n<!-- more -->\n<h1>动态规划的适用情况</h1>\n<ol>\n<li>\n<p>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>\n</li>\n<li>\n<p>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p>\n</li>\n<li>\n<p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>\n</li>\n</ol>\n<p>问题具有最优子结构性质，我们才能写出最优解的递归方程；具有重叠子问题特性，我们才能通过避免重复计算来减少运行时间。</p>\n<p>综上所述，动态规划的关键是 —— <strong>记忆</strong>，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。</p>\n<h1>实例</h1>\n<h2>斐波那契数列</h2>\n<p>只用递归来实现：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> fibonacci <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">?</span> n <span class="token punctuation">:</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>这种实现不会记录先前操作的结果，每次求值都会进行无谓的重复运算。通过给它添加记忆，来优化它的时间复杂度:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> fibonacci <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\t<span class="token keyword">var</span> fib <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">var</span> res <span class="token operator">=</span> memor<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\t\t<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">!==</span> <span class="token string">\'number\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t\tres <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t\tmemo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>\n\t\t<span class="token punctuation">}</span>\n\t\t<span class="token keyword">return</span> res<span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\t<span class="token keyword">return</span> fib<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>通过创建一个名为 memo 的数组，来保存子问题的结果。memo 保存在闭包中。当函数调用时，就会首先检查 memo 数组，如果已经存在，就直接返回结果。</p>\n<p>总之，这个例子很好的说明了动态规划的关键，即用空间换时间。</p>\n<h2>01背包</h2>\n<p>01 背包是动态规划中比较简单的一个问题。理解它，能清楚动态规划两个重要概念：状态和状态转移方程。</p>\n<p>假设编号分别为 a,b,c,d,e 的五件物品，重量分别是 2,2,6,5,4，价值分别是 6,3,5,4,6，现在有一个承重为 10 的背包，如何装入物品具有最大价值？</p>\n<h3>思路分析</h3>\n<p>首先我们来找状态。动态规划的一个重要思路就是把大问题分解成小问题。小问题除了规模更小，本质上还是相同的问题。我们可以从承重为 0 的背包开始，再逐渐增加到承重为 10 的背包。具体情况，结合下图讲解：</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.625%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAAoklEQVQI14WMOwrCQBRF30ZmY6JV2lhauQctLQwoWvsr1CgksbSIlR9EQZdghnmDoMlc4xRT2FgcOFwuh4bNHTr+ClEk0E8ExECgsmlgemLMzk+Ed2PdcWQsbwXGB4VJ6aO9tMyvL6wvDOr6Kdq1EFFMCBIC9Qje1oPW2mKMcc6KLd9NKeXIHhlMUdgPBfUUreoC8b8gaxfAT1BKiTx/g8vPB5qZyW3oY1k+AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="01&#x80CC;&#x5305;" title="" src="/static/531ac3d0c97e51a6ccee33bf7261b91d-df60d.jpg" srcset="/static/531ac3d0c97e51a6ccee33bf7261b91d-45144.jpg 188w,\n/static/531ac3d0c97e51a6ccee33bf7261b91d-2f941.jpg 375w,\n/static/531ac3d0c97e51a6ccee33bf7261b91d-df60d.jpg 750w,\n/static/531ac3d0c97e51a6ccee33bf7261b91d-182df.jpg 800w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  \n<figcaption>01&#x80CC;&#x5305;</figcaption></body></html>\n<p>当背包的承重为 2，行数为 2 时（从下到上递增），求的是前两个物品 d,e 装入背包里能达到的最大值。当背包的体积为 8，行数为 5 时，求的是前 5 个物品装入背包能达到的最大值。有没有发现，以上句子都是一个句式。形式化的表示它们，定义 d(i,j)为前 i 个物品装到剩余体积为 j 的背包里能达到的最大值。那么上面两句即为：d(2,2)和 d(5,8)。这样看是不是简洁多了。这两个符号就是我们要找的状态，即<strong>状态 d(i,j)为前 i 个物品装到剩余体积为 j 的背包里能达到的最大值。</strong></p>\n<p>上面那么多的文字，用一句话概括就是：根据子问题定义状态！　你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为 d(n, C)：前 n 个物品（0,1,2…,n-1）装入剩余容量为 C 的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？　顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。</p>\n<p>要明白状态转移方程，你要明白上面的表格是这么填的。随便挑一个表格(a，9)，此时背包容量为 9，可以选 abcde 五种物品，我们要找出容量的最大值，对待每个物品的具体策略是放入物品 a 和不放入物品 a 这两种情况：</p>\n<ul>\n<li>情况 a: 假如放入物品 a, 则背包容量变为 9-2=7，还剩 b,c,d,e 四种物品。所以该情况下的最大值 = (b,7) + 物品 a 的价值 6，即 9+6。</li>\n<li>情况 b: 假如不放入物品 a, 背包容量不变为 9，还剩 b,c,d,e 四种物品。所以该情况下的最大值 = (b, 9)，即 10。</li>\n</ul>\n<p>所以现在(a, 9) = max( (b,7)+6, b(9) ) = max(9+6，10) = 15。max( (b,7)+6, b(9) )就是状态转移方程的具体体现。</p>\n<h4>代码实现</h4>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">packageMaxValue</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span> value<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token comment" spellcheck="true">// 省略参数合法性校验</span>\n    <span class="token keyword">let</span> bagMatrix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;=</span> size<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//size是背包的大小</span>\n        <span class="token comment" spellcheck="true">// js不能直接创建二维数组，所以在此初始化数组</span>\n        bagMatrix<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment" spellcheck="true">// 背包的容量为0，那么一个东西也装不下，此时的值肯定也是为0</span>\n            <span class="token keyword">if</span><span class="token punctuation">(</span>w <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                bagMatrix<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>\n                <span class="token keyword">continue</span>\n            <span class="token punctuation">}</span>\n            <span class="token comment" spellcheck="true">// 背包的容量小于物品j的重量，那么就没有上述情况a了</span>\n            <span class="token keyword">if</span><span class="token punctuation">(</span>w <span class="token operator">&lt;</span> weight<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n                bagMatrix<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> bagMatrix<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>\n                <span class="token keyword">continue</span>\n            <span class="token punctuation">}</span>\n            bagMatrix<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bagMatrix<span class="token punctuation">[</span>w<span class="token operator">-</span>weight<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> bagMatrix<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> bagMatrix\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>参考链接：</p>\n<ul>\n<li><a href="http://www.hawstein.com/posts/dp-knapsack.html">动态规划之背包问题（一）\n</a></li>\n<li><a href="https://segmentfault.com/a/1190000006082676">js实现01背包问题</a></li>\n</ul>',frontmatter:{layout:"post",title:"初识动态规划",path:"/初识动态规划/",categories:["算法与数据结构"],description:"最近在参见各大公司的笔试，发现动态规划的题目出现率很高，基本上还是第一题。所以，觉得有必要认真补一下。<!--more-->",date:"2017/09/16"}}},{post:{html:'<h1>目录</h1>\n<p>原本以为写不了多少，写着写着发现有很多内容。特地在这里列一下提纲。</p>\n<ul>HTML\n  <ul>\n    <li>常用的meta头:\n      <ul>\n        <li>name</li>\n        <li>http-equiv</li>\n      </ul>\n    </li>\n    <li>对标签语义化的理解:</li>\n    <li>HTML5 新特性:\n      <ul>\n        <li>Html5移除的元素</li>\n        <li>Html5的基本布局（语义化的标记）</li>\n        <li>Html5对表单的支持</li>\n        <li>Html5中的Media</li>\n        <li>动画元素Canvas</li>\n        <li>Drag&Drop</li>\n        <li>Html5的ApplicationCache</li>\n        <li>Local storge</li>\n      </ul>\n    </li>\n    <li>HTTP访问控制（CORS）</li>\n  </ul>\n</ul>\n<h1>核心思路</h1>\n<p>校招面试和社招面试会有什么不同？　借用一张图说明：</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 640px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAC9UlEQVQ4y3VUyW7bSBTU/3/NAAPkEAw8SGYydmJbiyWRFMW9ue+LaZKSg0p1K4Occig22GwWq169x1Wm/YPOW6MPXjAEewyhhi7S0ccGccKQnDHENtcb+tj6iTP6yMQgDILv+C8oTvdYdd4GS25hjDS0p2c05hqdtcNcBQiMDcLTFvbxEcLcoRZnmLsHCGOLJjzD19aIuV/Ye1xyF72/w0peLoWL10CD8+Ujgq9/wyemKkR4PiI6a4gtHUVgwdV3cLWt2g+MPfc1LHVCRLgWHh0eSSgOuJQ+Zm7MVYwqtHHpcqLE+1Djvf89rn2Fa8uzTYprJW6EHWt2rQVrqMP67yP2d38ifPqEsYiQemcEpwN8IrINxPYJfRYidgwqdvB9aEhckTAjR8xaSoUMYMwFxtRF62rIWDO5znWKhSqnJsdUE1JJW1JVrdQrB/8rlc9ofRA6CUMD1u4bpjLCG4nLwMRbIbDw0FDEeM1jjGVCZZG6X0j6KtemUM8G7vdpwDrG6MOfhO9NzNbR4Xz+AJOW44e/MPDQ4fke+uYbLH2LzcNn6PxwyJASz1RkmWchcU6oGNhUsmwsH0PR8c6U3qhwyAIUwuJhfrFNWcdEqZlpW65jlTJ91qurblaV9UyFsrDNOlnDjk15LQNMiYNX+4Bk/4jRM2gph6PtbooYhuAasF1K4aqQhHkk9nDYo6l9xMIuaTkYK9nhF96MTLnZ38Og7d54xsSUXYN9p78oopQ2HfZhFbmwjhsmztrz46lDsspXvdz5W1r2dqrLr6VHCE6ASXUxk6MVBnNtC2VNrcRFpS1txkw2wsL3ZpLNmY2WI7zqXI5eZmFw9yjXd9Dv/kB/+IIxu41e5uhqOiQy9t+lSVSiSx1gVmRELgktNO6TJFwrwpGRd84G1fkJA1VPha+SmysGVoS8D0ng055QAUiyicqm3CEhkZponUescuNfSFLpv+Ufpw0OkEF1TL8X/NuwBL/ASZGQzzn7rX9Aw/dqWm1IlvPP9QM7XE/0tIBQYQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="&#x6821;&#x62DB;&#x548C;&#x793E;&#x62DB;" title="" src="/static/a5d674ffb3770162823f345840e2a0fa-fd19a.png" srcset="/static/a5d674ffb3770162823f345840e2a0fa-f0ee2.png 188w,\n/static/a5d674ffb3770162823f345840e2a0fa-032e2.png 375w,\n/static/a5d674ffb3770162823f345840e2a0fa-fd19a.png 640w" sizes="(max-width: 640px) 100vw, 640px">\n    </span>\n  </span>\n  \n<figcaption>&#x6821;&#x62DB;&#x548C;&#x793E;&#x62DB;</figcaption></body></html>\n<p>校招面试侧重潜力考察。看了自己的简历，发现缺乏能证明自我潜力的项目，都是一些小项目，缺乏深度。那该怎么办，时间已经不多了！　最近，我在看《Eloquentjavascript》，发现自己的基础不扎实，缺少代码量。如果硬着头皮写项目，写不出多有深度的作品。所以，还是准备先读完《Eloquentjavascript》，做完课后的习题再说。</p>\n<hr>\n<h1>前端基础</h1>\n<p>虽然清楚自己基础不扎实，但心里还是没有底。所以准备浏览一下前端的六个必备基础知识:<strong>HTML、CSS、JavaScript、移动 Web 开发、调试、HTTP 网络知识</strong>。看一下自己了解的怎么样。</p>\n<h1>HTML</h1>\n<h2>1.常用的meta</h2>\n<p>讲真的，除了 viewport 和 charset,其他的 meta 都没印象。\n在网上找了<a href="https://segmentfault.com/a/1190000004279791">《HTML meta标签总结与属性使用介绍》</a>这篇文章，仔细地浏览完，才知道 meta 是什么，和一些常用 meta 的意义。</p>\n<p>meta 是用来描述数据的数据。它不会显示在页面上，但是浏览器，搜索引擎和其他网络服务可以识别。它主要用于定义页面的说明、关键字，最后修改的日期和其他元数据。</p>\n<p>meta 标签共有两个属性，分别是<strong>http-equiv 属性</strong>和<strong>name 属性</strong>。</p>\n<h3>1.1 name</h3>\n<p>name 属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为 content，content 中的内容是对 name 填入类型的具体描述，便于搜索引擎抓取。\nmeta 标签中 name 属性语法格式是：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>参数<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>具体的描述<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>。\n</code></pre>\n      </div>\n<p>name 的常见参数有 keywords,description,viewport,robots(定义搜索引擎爬虫的索引方式),author,generator(用于标明网页是什么软件做的),copyright(版权),revisit-after(搜索引擎爬虫重访时间)和 renderer(双核浏览器渲染方式)。</p>\n<h3>1.2 http-equiv</h3>\n<p>equiv 的全称是”equivalent”,在这里的意思是相当于。http-equiv 的完整意思是相当于 HTTP 的作用,比如说定义一些 HTTP 参数。</p>\n<p>meta 标签中 http-equiv 属性语法格式是：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>参数<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>具体的描述<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<p>http-equivd 的属性主要有 X-UA-Compatible(浏览器采取何种版本渲染当前页面)，cache-control(指定请求和响应遵循的缓存机制），expires(网页到期时间)，refresh(自动刷新并指向某页面)和 Set-Cookie(Cookie 设定)。</p>\n<p>关于设定网页字符集，推荐使用 HTML5 的方式：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<p>现在，才知道 meta 的自定义属性有这么多，有些属性竟然涉及到 SEO 和 HTTP 协议。总之，感谢作者的付出。不过关于 cache-control 的介绍并没有深入，如定义最佳 cache-control 策略。毕竟文章主要是讲 meta，扯的太多，容易使主旨不明确。\n之后，我会自己写篇博文介绍一下网站优化。</p>\n<hr>\n<h2>2.标签语义化</h2>\n<p>又发现一个不懂的知识点。</p>\n<p>首先，我们要搞清楚为什么需要标签语义化。因为人们想要对 web 上的内容作各种处理和挖掘，所以让机器能够更好地读懂 Web 上发布的各种内容就变得越来越重要。</p>\n<p>那如何让机器理解网页上的内容？　主要有两种途径：</p>\n<ul>\n<li>让机器人的理解能力赶上人类，也就是发展人工智能。</li>\n<li>我们应该在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度（HTML 本身就已经是朝这个方向迈出的一小步了）。</li>\n</ul>\n<p>第一种途径是关于人工智能。第二中途径正是万维网创始人 Tim Berners-Lee 爵士提出的美好愿景：语义网。简单来说就是让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读。显然，两天路都不好走。而标签语义化正是第二条途径上的一小步。</p>\n<p>其实，HTML 一直在往语义化的方向上努力，许多元素、属性在设计的时候，就已经考虑了如何让各种用户代理甚至网络爬虫更好地理解 HTML 文档。HTML5 更是在之前规范的基础上，将所有表现层（presentational）的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。现在就等这些标准被广泛地接受，才能使这些语义元素有意义。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href="https://www.zhihu.com/question/20455165">如何理解Web语义化</a></li>\n<li><a href="https://github.com/Justineo/slideshows">强烈推荐：https://github.com/Justineo/slideshows</a></li>\n</ul>\n<hr>\n<h2>3.HTML5新特性</h2>\n<p>这方面的知识面也是东拼西凑出来的，是时候总结一下了。</p>\n<h3>3.1 Html5移除的元素</h3>\n<p>因为 Html 的作用是标记文本的结构，而非用于网页的表现，所以用于网页表现的<front>, <center>等可以用 CSS 实现的元素被移除，其他被移除的元素还有：font, center, strike, big, s, u, acronym, applet, dir 等。此外还有一些无用或者不被使用的元素属性被移除。这些元素在的时候，你可能都没见过。现在被移除了，就更没必要知道了。</p>\n<h3>3.2 Html5的基本布局（语义化的标记）</h3>\n<p>就像上一节标签语义化说的，为了让 HTML 文档更好地被理解，Html5 增加了不少可以表达更丰富语义的元素：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token doctype">&lt;!DOCTYPE html></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">></span></span>导航<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span><span class="token punctuation">></span></span>标签则应该是用来放置诸如一篇文章或是博客一类的信息\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n\t\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">></span></span>标签用来分组相类似的信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aside</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aside</span><span class="token punctuation">></span></span>\n  \t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aside</span><span class="token punctuation">></span></span>侧边栏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aside</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>页脚<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<h3>3.3 Html5对表单的支持</h3>\n<p>Html5 新增了多个控件类型，如输入网址的 url 类型，输入电子邮箱地址的 email 类型，用于输入日期的 date 类型，更有用于输入颜色的 color 类型等等。更为神奇的是这些类型还内建表单验证，如 required 属性就说明该表项不能为空，max 属性提供了该表项输入允许的最大值，当然在 html4 中这些功能也可以通过 JavaScript 来实现，但是的内建在 html5 中的表单验证优越性不言而喻。需要注意的是，现在 Html5 的输入类型还没有被所有浏览器所支持。\n代码：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>\n    Email:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">required</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>br</span><span class="token punctuation">></span></span>\n    Number:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>br</span><span class="token punctuation">></span></span>\n    Date :<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>date<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>br</span><span class="token punctuation">></span></span>\n    File:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">accept</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image/png<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>br</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<h3>3.4 Html5中的Media</h3>\n<p>Html5 的另一大特点就是不借助其他插件就可播放视频和音频文件。具体地实现，要考虑视频文件格式的版权问题,各大浏览器不能做到全部支持，所以代码要这样写：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>vedio</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movie.mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movie.ogv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">data</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movie.swf<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movie.mp4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Download<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>vedio</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<p><object> 元素（或者称作 HTML 嵌入对象元素）表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源。data 属性的值是一个合法的 URL 作为资源的地址</p>\n<h3>3.5 动画元素Canvas</h3>\n<p>HTML5 的 canvas 元素可以使用 JavaScript 直接在网页上绘制图像</p>\n<h3>3.6 Drag&#x26;Drop</h3>\n<p>HTML5 为元素新增了用于拖拽的属性 draggable，这个属性决定了元素是否能被拖拽， 如果 draggable=”true”，则元素可被拖拽，否则只能选择元素的文本。下面几行简单的代码可以简单的说明 Html5 的 Drag&#x26;Drop 特性：</p>\n<div class="gatsby-highlight">\n      <pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">draggable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">ondragstart</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dragstartHandler(event)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\tDrag me!Drag me!!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">draggable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Don’t drag me!!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>\n</code></pre>\n      </div>\n<h3>3.7 Html 5的Application Cache</h3>\n<p>现在 web app 有多火，相信大家都知道。但是 web 应用依赖网络，而网络不是随时都有的。Html5 的离线存储使得这个问题迎刃而解。HTML5 的 web storage API 采用了离线缓存，会生成一个清单文件（manifest file），这个清单文件实质就是一系列的 URL 列表文件，这些 URL 分别指向页面当中的 HTML,CSS,Javascrpit,图片等相关内容。</p>\n<p>一个 Mainfest file 实例：</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>–  CACHE MANIFEST\n   /demo/test/style.css\n   /demo/test/jquery.min.js\n   /demo/test/test.html</code></pre>\n      </div>\n<p>当使用离线应用时，应用会引入这一清单文件，浏览器读取这一文件，下载相应的文件，并将其缓存到本地。使得这些 web 应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。</p>\n<h3>3.8 local storage</h3>\n<p>假如你需要存储的只是简单的数据则可以使用 Web Storage.\nWeb Storage 实际上由两部分组成：sessionStorage 与 localStorage。</p>\n<ul>\n<li>\n<p>用于本地存储一个会话（セッション）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁.因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</p>\n</li>\n<li>\n<p>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>\n</li>\n</ul>\n<p>参考链接：</p>\n<ul>\n<li><a href="https://www.pureweber.com/article/html5/">Html5新特性概览</a></li>\n</ul>\n<hr>\n<h2>4.HTTP访问控制（CORS）</h2>\n<p>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n<p>出于安全考虑，浏览器会限制从脚本内发起的跨域 HTTP 请求。不过有些时候，跨站请求能正常发送，只不过返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理。</p>\n<p>跨域资源共享（CORS）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行实际开发中，可以使用 XMLHttpRequest 或 Fetch 使用 CORS:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> invocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">\'http://bar.other/resources/public-data/\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">callOtherDomain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    \n    invocation<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">\'GET\'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    invocation<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n    invocation<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>',
frontmatter:{layout:"post",title:"前端校招会考察什么——HTML篇",path:"/前端校招会考察什么（一）/",categories:["HTML"],description:"参加了不少公司的笔试，工作却还没有着落。感觉是时候总结一下，为秋招的最后冲刺做准备。这篇文章只涉及HTML方面。<!--more-->",date:"2017/09/22"}}},{post:{html:'<h1>目录</h1>\n<ul>JavaScript\n  <ul>\n    <li>DOM结构和操作:</li>\n    <li>JSON:</li>\n    <li>语言特性:\n      <ul>\n        <li>Function composition</li>\n        <li>原型继承</li>\n        <li>闭包</li>\n        <li>事件委托</li>\n        <li>作用域</li>\n        <li>高阶函数</li>\n      </ul>\n    </li>\n    <li>异步:\n      <ul>\n        <li>异步控制流</li>\n        <li>Promise</li>\n        <li>Callbacks</li>\n      </ul>\n    </li>\n    <li>流行框架:\n      <ul>\n        <li>React</li>\n      </ul>\n    </li>\n    <li>了解jQuery:</li>\n    <li>ES6新特性:</li>\n  </ul>\n</ul>\n<p>正在完成中。。。</p>\n<h1>DOM结构和操作</h1>\n<p>DOM 的全称是文档对象模型。对于 DOM，你可能知道它是 web 页面和脚本或程序语言的桥梁。通过它，你能改变 HTML 文档的结构、样式和内容。但你是否知道，DOM 是 web 页面的完全的面向对象表述。所有操作和创建 web 页面的属性，方法和事件都会被组织成对象的形式（例如， document 对象表示文档本身， table 对象实现了特定的 HTMLTableElement DOM 接口来访问 HTML 表格等）。</p>\n<p>另外，DOM 结构中的每个节点都是对象。这些节点以树的形式组织起来：</p>\n<img src="/907fb6c36155137731f0f394ead0b0c7.svg" alt="树型结构">\n<p>DOM 节点又都包含了许多指向相邻节点的链接：</p>\n<img src="/f5fb2ba0261b99ccd5f2a59174dc011b.svg" alt="节点间的链接">\n<p>在这种树型结构中，节点们彼此嵌套，非常适合用递归函数来遍历 DOM。</p>\n<p>比如，你想通过标签名获取元素：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> find_the_DOM <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">find</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">func</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  node <span class="token operator">=</span> node<span class="token punctuation">.</span>firstChild<span class="token punctuation">;</span>\n  <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">find</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    node <span class="token operator">=</span> node<span class="token punctuation">.</span>nextSibling<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> byTagName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> tagName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> arry <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\ttagName <span class="token operator">=</span> tagName<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">find_the_DOM</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> document<span class="token punctuation">.</span>ELEMENT_NODE<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>nodeName <span class="token operator">==</span> tagName<span class="token punctuation">)</span>\n        arry<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t<span class="token keyword">return</span> arry<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>大部分情况下，遍历节点是为了修改或添加节点。自然，DOM 结合 JS 给开发者提供了非常方便的 API 来修改文档、创建节点，获得属性值等。</p>\n<p>下面是在 web 和 XML 页面脚本中使用 DOM 时，一些常用的 API 简要列表:</p>\n<ul>\n<li>document.getElementById(id)</li>\n<li>element.getElementsByTagName(name):返回的对象是动态变更的。</li>\n<li>document.createElement(name)</li>\n<li>document.createTextNode(string)</li>\n<li>parentNode.appendChild(node)</li>\n<li>parentNode.removeChild(node)</li>\n<li>parentNode.replaceChild(new<em>node,old</em>node)</li>\n<li>element.innerHTML</li>\n<li>element.style.left</li>\n<li>element.setAttribute</li>\n<li>element.getAttribute</li>\n<li>element.addEventListener</li>\n<li>window.onload</li>\n</ul>\n<p>看一个简单的例子，编写一个“语法高亮器”，搜索带有 data-language 属性的 pre 标签，并尝试加亮语言中的关键字：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">highlightCode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> keywords<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> text <span class="token operator">=</span> node<span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>\n  node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 清空节点</span>\n\n  <span class="token keyword">var</span> match<span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  <span class="token comment" spellcheck="true">//不断循环找出文本中的关键字，并为关键字前的文本创建单独的节点，而将匹配的关键字包裹在&lt;strong>元素中。最后为尾部的文本创建单独的节点。</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>match <span class="token operator">=</span> keywords<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> before <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> match<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>before<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> strong <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"strong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    strong<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>strong<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    pos <span class="token operator">=</span> keywords<span class="token punctuation">.</span>lastIndex<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">var</span> after <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>after<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>具体例子可以去<a href="http://eloquentjavascript.net/13_dom.html">这里</a>看。</p>\n<p>参考链接：</p>\n<ul>\n<li>《JavaScript 编程精解》（英文名：eloquentjavascript）</li>\n</ul>\n<hr>\n<h1>JSON</h1>\n<p>JSON 是一种保存数据的格式。它的编写方式与编写 Js 数组和对象的方式十分相似，不过有些限制。比如属性都必须用双引号扩起来，而且只能使用简单的数据表达式，不能填写函数调用、变量以及任何含有实际运算的代码。Json 中也不可以包含注释。所以你看，Json 只是一个保存数据的格式。</p>\n<h3>方法</h3>\n<p>JSON.parse()\n解析一个 JSON 字符串，可选地转换生成的值及其属性，并返回值。</p>\n<p>JSON.stringify()\n返回与指定值相对应的一个 JSON 字符串，可选地仅包含某些属性或以用户定义的方式替换属性值。</p>\n<hr>\n<h1>语言特性</h1>\n<h2>Function composition</h2>\n<p><span><a href="/掌握JavaScript面试：什么是功能组合？/" >掌握 JavaScript 面试：什么是函数组合？</a></span></p>\n<hr>\n<h2>原型继承</h2>\n<p><span><a href="/Javascript中的多态和继承/" >JavaScript 中的多态和继承</a></span></p>\n<hr>\n<h2>闭包</h2>\n<h3>作用域</h3>\n<p>了解闭包前，你要先知道什么是作用域。因为，闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。</p>\n<p>作用域包括词法作用域和执行环境。</p>\n<p>词法描述了源代码中的范围。在 JavaScript 中，变量的作用域是由它在源代码中所处位置决定的（显然如此），并且嵌套的函数可以访问到其外层作用域中声明的变量。这种内部函数能访问外部函数的数据结构其实是”差异化继承(differential inherutance)“的体现。有兴趣的话可以去看《Javascript 编程精粹》中的第 50 页(继承-原型)。</p>\n<blockquote>\n<p>if语句或while语句以及其他类似循环结构的语句块不能创建新的作用域。只用function语句块能创建新的作用域。</p>\n</blockquote>\n<p>当程序运行的时候，会创建一个存储变量和变量值的存储系统。这些内存中的作用域结构被称为执行环境。</p>\n<p>执行环境实在程序运行时才被创建的，不是在代码输入时被创建的。执行环境能控制在程序执行过程中不同点能访问哪些变量。</p>\n<h3>什么是闭包？</h3>\n<p>简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。换句话说，闭包给你从内部函数访问外部函数的作用域的途径。在 JavaScript 中，闭包在每个函数被创建时形成。</p>\n<p>要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。</p>\n<p>内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。</p>\n<h3>闭包的使用例子</h3>\n<p>一样东西很重要，肯定是因为他有非凡的作用。闭包在 JavaScript 中常用来实现对象数据的私有，在事件处理和回调函数中也常常会用到它，此外还有偏函数应用（partial applications）和柯里化（currying），以及其他函数式编程模式。</p>\n<h4>实现对象的私有数据</h4>\n<p>闭包的用途之一是实现对象的私有数据。数据私有是让我们能够面向接口编程而不是面向实现编程的基础。而面向接口编程是一个重要的概念，有助于我们创建更加健壮的软件，因为实现细节比接口约定相对来说更加容易被改变。</p>\n<p>在 JavaScript 中，闭包是用来实现数据私有的原生机制。当你使用闭包进行数据私有画时，被封装的变量只能声明在外部函数中。你只能通过返回的内部函数的特权方法来获取数据。具体的例子如下：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> getSecret <span class="token operator">=</span> <span class="token punctuation">(</span>secret<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> secret\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>在这个例子中，get()方法就是特权方法，你只能通过它访问 secret 变量。</p>\n<p>对象不是唯一的产生私有数据的方式。闭包还可以被用来创建有状态的函数，这些函数的执行过程可能由它们自身的内部状态所决定。例如：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> secret <span class="token operator">=</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> msg<span class="token punctuation">;</span>\n\n<span class="token function">secret</span><span class="token punctuation">(</span><span class="token string">\'haha\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// output: () => msg</span>\n<span class="token function">secret</span><span class="token punctuation">(</span><span class="token string">\'haha\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// output: \'haha\'</span>\n</code></pre>\n      </div>\n<p>在函数式编程中，闭包经常用于偏函数应用和柯里化。</p>\n<p>在 Js 中，函数也是值，从而我们可以用更有趣的方式去操控它们。柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。</p>\n<p>curry 的具体实现如下：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>Function<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">\'curry\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">var</span> slice <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">,</span>\n      args <span class="token operator">=</span> slice<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">,</span>\n      that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> that<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>slice<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>有没有觉得和第一个例子很像。柯里化通过闭包作用域来准备参数。我们实际使用中就可以这样：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">var</span> add1 <span class="token operator">=</span> add<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// output: 7</span>\n</code></pre>\n      </div>\n<hr>\n<h2>事件委托</h2>\n<p><span><a href="https://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html" >JavaScript 事件代理和委托（Delegation）</a></span></p>\n<p>看完这篇文章，突然想到博客中有不少列表。而我只是简单的给每个 li 添加点击的响应函数，没有使用事件委托，琢磨着应该完善一下。谁知道，react 的 onClick 本身就是事件委托，你完全可以直接在 li 上绑定。通过 JSX 这种方式绑定的事件是合成事件，和原生事件是不同的。</p>\n<h2>高阶函数</h2>\n<p>如果一个函数操作其他函数，即将其他函数作为参数或将函数作为返回值，那么我们可以将其称为高阶函数。</p>\n<h1>Promise</h1>\n<p><span><a href="/上手Promise/" >上手 Promise</a></span></p>\n<h1>流行框架</h1>\n<h2>React</h2>\n<h1>了解JQuery</h1>\n<h1>ES6新特性</h1>',frontmatter:{layout:"post",title:"前端校招会考察什么——JavaScript篇",path:"/前端校招会考察什么（三）/",categories:["JavaScript"],description:"JavaScript是最重要的，毕竟它是一门编程语言。文章主要包括DOM和JSON、语言特性、异步、流行框架、JQurey和ES6新特性。<!--more-->",date:"2017/10/03"}}},{post:{html:'<h1>盒模型</h1>\n<p>我们都知道文档中的每一个元素都是一个矩形盒子。如果有人不信的话，只要打开一下 Developers Tool，再去选中一个元素，就会发现一块蓝色的矩形。因此，渲染引擎的目标就是确定这些盒子的尺寸和属性。</p>\n<p>在 CSS 中，我们使用盒模型描述这些盒子。在盒模型的定义中，每个盒子有四条边：border edge, padding edge\n,margin edge 和 content edge。直观的表示，如图：</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 550px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAABG0lEQVQoz52SgU6DMBCG9/7PZYyYiJigFCRre22RDXQkoJtRwL+wQYQlQy8/R4/ed5deWXneQxQ9Z1m2+7utiqIIKfd5xrcfadku11fdWvhO19cuu/Eil2lfvC2Rww/vn42F700thCSpiBSOwAL26D/1oeBSKT3sDqErqhFWpCUSBDEWSoKpNN2keDbbJHkJGMMyjmOkWZ60K8oRlkICJvBStjPTxsDn+SvSUFdOOlNHdjDNYVK6g/Mh7VdnW68jz8JlVVk4y/u2Uxgn6UcSBMyYxBizK4r9yXCl8FrrCwMDP+8MEh4/0oWBRWGEwnwtBLfia7xkiI9cYOs4sOmZT5NYqBF2TXMrDg7fQ/1iEjqz8Ip/H+G6af8h2A9Z1QCs8OXMMgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="&#x76D2;&#x6A21;&#x578B;" title="" src="/static/5425b4f0e5a5c05ddedb5fd3200b8ba1-c20c8.png" srcset="/static/5425b4f0e5a5c05ddedb5fd3200b8ba1-65b51.png 188w,\n/static/5425b4f0e5a5c05ddedb5fd3200b8ba1-4a4a4.png 375w,\n/static/5425b4f0e5a5c05ddedb5fd3200b8ba1-c20c8.png 550w" sizes="(max-width: 550px) 100vw, 550px">\n    </span>\n  </span>\n  \n<figcaption>&#x76D2;&#x6A21;&#x578B;</figcaption></body></html>\n<h4>一些要点:</h4>\n<p>如果你使用 box-sizing: border-box ，那么只有 width, min-width, max-width, height, min-height 与 max-height 这些属性能控制内容大小。</p>\n<p>内边距区域 padding area 延伸到包围 padding 的边框。如果内容区域 content area 设置了背景、颜色或者图片，这些样式将会延伸到 padding 上(译者注：而不仅仅是作用于内容区域)。它位于内边距边界内部, 它的大小为 padding-box  宽与 padding-box 高。</p>\n<p>在外边距合并的情况下，由于盒之间共享外边距，外边距不容易弄清楚。你可以使用 flex 来防止这种情况。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model">盒子模型</a></li>\n</ul>\n<hr>\n<h1>Flexbox</h1>\n<p>新东西的出现，肯定有他的原因。我认为 Flexbox 的出现是为了适应不同屏幕尺寸。</p>\n<p>就从 flex 这个属性开始讲。flex 属性其实是 flex-grow，flex-shrink 和 flex-basis 的简写。flex-grow 是来定义项目放大的比例的，与之相对的 flex-shrink 则是定义项目缩小的比例的。这两个属性使得元素具有填充可用空间和收缩来避免溢出的特性。我认为之所以取名为弹性盒子，就是为了强调这一新的布局模式有强大的灵活性,如能自动调整大小，拉伸，收缩和移动。而 flex-grow 和 flex-shrink 是很好的体现，它们俩使你可以控制布局的伸缩性。其他的属性如 order，flex-direction，justify-content，align-items 和 align-self 等等，都是为了让你写出能在不同屏幕尺寸上灵活适应的布局。</p>\n<p>学习 felxbox，结合下面这张图看各个属性的定义，能更好的理解。具体的学习资料可以看参考链接给出的<strong>Flex 布局教程：语法篇</strong>。</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 563px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 59.147424511545296%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABqUlEQVQoz3WRa2+aUACG+f//YF/2ocvWua2uy5rFFLxVkKLcqyIcrMBBD6JFQcslWbKdM92JXbPkDeF5eN8cAsw+8ffxw+uknnqOma++7jBZPAL6N6NfM8VPm3mrWos4JbzL3VY+ZY9YeJ0cNItZ+4g0TLY0t347Arcrly0joVr1q1g8WD+e2Lfb7jva23x/U8DOv+M0NEokkETCXr7echcl4o9IPbmGvRf4J+S13cAZgGDgBKoX6XDzYJvrhaLMETZDN8RGnaNkxhneQnJ8UvNjw4GP4J6MLRhe9caXnMKOkLL6JU2mKNQ7TvKBlWttnZiwiqaNITxg/Nw1uXGkLH9OrMFpjBs0ZOwpalBpdqKNY22WDZ3dcYyfam5KPNj9fxySA2XVlwVLATt6MpH3QG5qirU5jUczmwdrGlFXUCCfm661WIPbvg2pEUw4GfFkXKyEA+rR5BidxpP4MVHrVOJv+xzx57Uy7jOpp+Uulw3qmfSV/sD8sZXJ13v9hho8/nvDp71aJl0V8I6JoRHqN17rfSB+QaBJszAaL9A84dJm/e5lINWXU/Y3NUhouhzcqVoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="Flexbox" title="" src="/static/fe633eb0ed2e02924982b8397a14ce25-2a4fe.png" srcset="/static/fe633eb0ed2e02924982b8397a14ce25-212ff.png 188w,\n/static/fe633eb0ed2e02924982b8397a14ce25-fe04f.png 375w,\n/static/fe633eb0ed2e02924982b8397a14ce25-2a4fe.png 563w" sizes="(max-width: 563px) 100vw, 563px">\n    </span>\n  </span>\n  \n<figcaption>FLexbox</figcaption></body></html>\n<p>了解来 Flexbox 的属性之后，不找点东西练练手，就不会清楚自己掌握了多少。你可以去下面的参考链接上找实例，也可以看一下我写的一些实例：<a href="https://github.com/FourEyebrowXiake/Eloquent-JavaScript-Exercise/tree/master/flex-practice">flex-practice</a></p>\n<ul>\n<li>\n<p>参考链接</p>\n<ul>\n<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes">使用弹性盒子</a></li>\n<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></li>\n<li><a href="https://medium.freecodecamp.org/the-ultimate-guide-to-flexbox-learning-through-examples-8c90248d4676">The Ultimate Guide to Flexbox — Learning Through Examples</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1>如何写出更好的css</h1>\n<p>CSS module 的出现使你能够更容易地组织 css 代码。每个组件的 CSS 被写到响应的文件中，彼此直接又不受影响，真是不要太好。</p>\n<p>还有其他的，如层级不宜过深，如何时用 ID 和何时用 class 和更具需求写 reset 等等。再深入点，涉及到页面重新绘制的管道：</p>\n<html><head></head><body>\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-bottom: 1.0725rem;; max-width: 750px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 14.3698468786808%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsSAAALEgHS3X78AAAA1klEQVQI1yXOz0vCYADG8f3ZXTrXrZgZZfSTpTJMLc3WdFCaTiqx2kKXbFge9A1el0nnb2/r8OELz+nR4jDFV7jFIvqTJugOaJ5JZc6DHdMsykSrJLnr9TkPTrhQnKhM9S1LJTBUTxOt9ys0GawTjzaQvvK8wvCmQG1f0DieUtAjLvcEdeMT60hQzvtkemuYfgb9fhXjJUXW28bs72A+7pLz0mhL4bAYW8QDix9RZzKc4d3O8W3Bgb5J8bDLq/v9LxzhThylwdPUpaPajq7V8yrtDzvZfgGR1sXYjCReVQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;" alt="pipe" title="" src="/static/bbb8bfc16477aafa2b0c94292189085a-245fd.png" srcset="/static/bbb8bfc16477aafa2b0c94292189085a-7aee9.png 188w,\n/static/bbb8bfc16477aafa2b0c94292189085a-2014b.png 375w,\n/static/bbb8bfc16477aafa2b0c94292189085a-245fd.png 750w,\n/static/bbb8bfc16477aafa2b0c94292189085a-79dda.png 849w" sizes="(max-width: 750px) 100vw, 750px">\n    </span>\n  </span>\n  \n<figcaption>pipe</figcaption></body></html>\n<p>当要改变 css 的属性时，尽量采用对管道影响最少的属性。可以访问<a href="https://csstriggers.com/">csstriggers.com</a>了解详情。</p>\n<p>说了这么多，我认为最重要的还是先写好标签，再来动你的样式文件。毕竟房子的结构不设置好，装修起来就很费劲。同样的，不先写好布局，在写其他的属性的话，会很乱。</p>\n<p>具体地说，当我准备开工的时候，在我创建一个 CSS 文件之前，我检查并对整个文档进行编码(HTML)，从开始 body 标签到结束整个 body 标签。不添加任何多余的 div、id 或 class。我会添加一些通用的 div，比如头部，内容，底部，因为我知道这些东西肯定会有。</p>\n<p>使用 CSS 的向后选择器来定义子元素。不要直接自动的为元素添加类或 id。请记住，如果一个文档没有良好的格式(结构)，CSS 是毫无价值的。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href="https://www.qianduan.net/the-fast-write-better-css-of-five-kinds-of-methods/">快速写出较好CSS的5种方法</a></li>\n</ul>',frontmatter:{layout:"post",title:"前端校招会考察什么——CSS篇",path:"/前端校招会考察什么（二）/",categories:["CSS"],description:"学CSS的肯定需要知道盒模型，接着就要了解CSS3动画、Flexbox等非常有用的CSS3知识，之后自然要清楚如何写出更好的CSS。<!--more-->",date:"2017/09/24"}}},{post:{html:'<blockquote>\n<p>原文链接: <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0">Master the JavaScript Interview: What is Function Composition?\n</a></p>\n</blockquote>\n<p>Function composition 是组合两个或多个函数以产生新功能的过程。</p>\n<p>组合在一起的函数就像一系列结合起来的管道。我们的数据在这些管道中流通。</p>\n<p>换种说法，Function composition 就是数学中的复合函数。函数’f(x)‘和函数’g(x)‘的组合可以被定义成’f(g(x))‘.它的调用顺序由内而外，依次是 x, g, f。</p>\n<p>换到编程的场景下，你可以把每个函数都当作一个动作。比如你要将用户的全名转换为 URL 段，为每个用户提供个人资料页面。为了做到这一点，你要经历一系列的步骤：</p>\n<ol>\n<li>根据空格，把名字字符串转换成数组</li>\n<li>遍历数组，将名称都转换成小写，并返回新数组。</li>\n<li>加入破折号</li>\n<li>对 URI 组件进行编码</li>\n</ol>\n<p>这是一个简单的实现：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascrpit"><code>const toSlug = input => encodeURIComponent(\n  input.split(\' \')\n    .map(str => str.toLowerCase())\n    .join(\'-\')\n);</code></pre>\n      </div>\n<p>不错，但是如果我告诉你，它可以更加可读呢？</p>\n<p>想象一下，每个操作都有一个对应的可组合的函数，就可以这样写：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascrpit"><code>const toSlug = input => encodeURIComponent(\n  join(\'-\')(\n    map(toLowerCase)(\n      split(\' \')(\n        input\n      )\n    )\n  )\n);\n\nconsole.log(toSlug(\'JS Cheerleader\')); // \'js-cheerleader\'</code></pre>\n      </div>\n<p>这看上去是不是很像‘f(g(x))’。不过，这种写法比上一种更加难读。</p>\n<p>为了实现函数间的组合，我们需要使用可复用的公共程序，如’split()’, ‘join()‘和 ‘map()‘。这是它们的实现：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> curry <span class="token operator">=</span> fn <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=></span> fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> join <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=></span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> toLowerCase <span class="token operator">=</span> str <span class="token operator">=></span> str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> split <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>splitOn<span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token operator">=></span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>splitOn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>除了’toLowerCase’之外，其他函数都可以从 Lodash/fb 中获得：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> curry<span class="token punctuation">,</span> map<span class="token punctuation">,</span> join<span class="token punctuation">,</span> split <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'lodash/fp\'</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>也可以像这样导入：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> curry <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'lodash/fp/curry\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'lodash/fp/map\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>这里我偷了点懒。注意这个 curry 从技术上来说，并不是一个真正的柯里化函数。真正的柯里化函数总会生成一个一元函数。这里的 curry 只是一个偏函数应用。请参考<a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8#.13tj19278">“柯里化和偏函数应用之间的区别是什么？”</a>这篇文章。不过，这里只是为了演示用途，我们就把它当作一个真正的柯里化函数好了。</p>\n<p>回过头看‘toSlug’的实现，这中写法很不优雅：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> toSlug <span class="token operator">=</span> input <span class="token operator">=></span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>\n  <span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'-\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>\n    <span class="token function">map</span><span class="token punctuation">(</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">(</span>\n      <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\' \'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>\n        input\n      <span class="token punctuation">)</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toSlug</span><span class="token punctuation">(</span><span class="token string">\'JS Cheerleader\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// \'js-cheerleader</span>\n</code></pre>\n      </div>\n<p>对我来说，这里的嵌套太多了，读起来有点让人摸不着头脑。我们可以用一个会自动组合这些函数的函数来扁平化嵌套，就是说，这个函数会从一个函数得到输出，并自动将它传递给下一个函数作为输入，直到得到最终值为止。</p>\n<p>细想一下，好像数组中有一个函数可以做差不多的事情。这个函数就是 reduce()，它用一系列值为参数，对每个值应用一个函数，最后累加成一个结果。值本身也可以函数。但是 reduce() 是从左到右递减，为了匹配上面的组合行为，我们需要它从右到左缩减。</p>\n<p>好事情是刚好数组也有一个 reduceRight() 方法可以干这事:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> compose <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>‘reduce’和’reduceRight’唯一的不同只有遍历的方向。我们可以用它从右到左迭代数组，将函数依次应用到每个数组元素上，最后得到累加值（v）。</p>\n<p>用 compose，我们就可以不需要嵌套来重写上面的组合：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> toSlug <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n\n  encodeURIComponent<span class="token punctuation">,</span>\n\n  <span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'-\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n\n  <span class="token function">map</span><span class="token punctuation">(</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">,</span>\n\n  <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\' \'</span><span class="token punctuation">)</span>\n\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toSlug</span><span class="token punctuation">(</span><span class="token string">\'JS Cheerleader\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// \'js-cheerleader\'</span>\n</code></pre>\n      </div>\n<p>当然，lodash/fp 也提供了 compose()。使用方法和上面一样。</p>\n<p>当以数学形式的组合从内到外的角度来思考时，compose 是不错的。它和符合 f(g(x))的形式。不过，如果想以从左到右的顺序的角度来思考，又该怎么办呢？</p>\n<p>还有另外一种形式，通常称为 pipe()。Lodash 称之为 flow():</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> pipe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> fn1 <span class="token operator">=</span> s <span class="token operator">=></span> s<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> fn2 <span class="token operator">=</span> s <span class="token operator">=></span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> fn3 <span class="token operator">=</span> s <span class="token operator">=></span> s <span class="token operator">+</span> <span class="token string">\'!\'</span>\n\n<span class="token keyword">const</span> newFunc <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>fn1<span class="token punctuation">,</span> fn2<span class="token punctuation">,</span> fn3<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">newFunc</span><span class="token punctuation">(</span><span class="token string">\'Time\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// emit!</span>\n</code></pre>\n      </div>\n<p>可以看到，这个实现与 compose() 几乎完全一样。唯一的不同之处是，这里是用 .reduce()，而不是 .reduceRight()，即是从左到右缩减，而不是从右到左。</p>\n<p>下面我们来看看用 pipe() 实现的 toSlug() 函数:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> toSlug <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>\n\n  <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\' \'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n\n  <span class="token function">map</span><span class="token punctuation">(</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">,</span>\n\n  <span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'-\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n\n  encodeURIComponent\n\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toSlug</span><span class="token punctuation">(</span><span class="token string">\'JS Cheerleader\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// \'js-cheerleader\'</span>\n</code></pre>\n      </div>\n<p>对我来说，对于我来说，这要更容易读懂一些。</p>\n<p>骨灰级的函数式程序员用函数组合定义他们的整个应用程序。而我经常用它来消除临时变量。仔细看看 pipe() 版本的 toSlug()，你会发现一些特殊之处。</p>\n<p>在命令式编程中，在一些变量上执行转换时，在转换的每个步骤中都会找到对变量的引用。而上面的 pipe() 实现是用不定参数（原文说是 points-free style）写的，就是说完全找不到它要操作的参数。</p>\n<p>我经常将管道（pipe）用在像单元测试和 Redux 状态 reducer 这类事情上，用来消除中间变量。中间变量的存在只用来保存一个操作到下一个操作之间的临时值。</p>\n<p>这玩意开始听起来会比较古怪，不过随着你用它练习，会发现在函数式编程中，你是在和相当抽象、广义的函数打交道，而在这样的函数中，事物的名称没那么重要。名称只会碍事。你会开始把变量当作是多余的样板。</p>\n<p>就是说，我认为 points-free style 可能会被用过头。它可能会变得太密集，较难理解。但是如果你搞糊涂了，这里有一个小窍门…你可以利用 flow 来跟踪是怎么回事：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> trace <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>label<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`== </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> label <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> x <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>下面是具体的使用方法：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> toSlug <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>\n  <span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">\'input\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\' \'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">\'after map\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'-\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  encodeURIComponent\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toSlug</span><span class="token punctuation">(</span><span class="token string">\'JS Cheerleader\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// \'== input:  JS Cheerleader\'</span>\n<span class="token comment" spellcheck="true">// \'== after map:  js,cheerleader\'</span>\n<span class="token comment" spellcheck="true">// \'js-cheerleader\'</span>\n</code></pre>\n      </div>\n<p>其实，trace()是 tap()的特殊形式。它可以让你对流过管道的每个值执行一些行为。明白了么？　管道（Pipe）？　水龙头(Tap)？　可以像下面这样编写 tap()：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> tap <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\n  <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>现在你可以看到为嘛 trace() 只是一个特殊情况下的 tap() 了：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> trace <span class="token operator">=</span> label <span class="token operator">=></span> <span class="token punctuation">{</span>\n\n  <span class="token keyword">return</span> <span class="token function">tap</span><span class="token punctuation">(</span>x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`== </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> label <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> x <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>你应该开始对函数式编程是什么样子，以及偏函数应用和柯里化如何与函数组合协作，来帮助你编写可读性更强的程序有点感觉了。</p>\n<p>参考链接:</p>\n<ul>\n<li><a href="http://www.10tiao.com/html/59/201702/2651551705/2.html">征服 JavaScript 面试：什么是函数组合</a></li>\n</ul>',
frontmatter:{layout:"post",title:"掌握JavaScript面试：什么是函数组合？",path:"/掌握JavaScript面试：什么是功能组合？/",categories:["JavaScript"],description:"这篇是“Master the JavaScript Interview: What is Function Composition”的译文。第一次翻译外文，十有八九会出错，但是总要试试。<!--more-->",date:"2017/10/05"}}},{post:{html:'<p><a href="https://github.com/FourEyebrowXiake/old-article">https://github.com/FourEyebrowXiake/old-article</a></p>\n<ul>\n<li>CSS 的重要性.md</li>\n<li>JavaScript 中的多态和继承.md</li>\n<li>JavaScript 语言精粹:数组.md</li>\n<li>JavaScript 语言精粹：方法.md</li>\n<li>JavaScript 语言精粹：方法（2）.md</li>\n<li>Js 语法基础：Array、String 常用方法.md</li>\n<li>Js 语法基础：作用域、闭包、this.md</li>\n<li>Js 语言精粹(2)-对象、函数.md</li>\n<li>css 布局(-):盒模型-display-float-position.md</li>\n<li>css 要点.md</li>\n<li>js 语言精粹(1)-精华与糟粕.md</li>\n<li>mongo_basics.md</li>\n<li>Redux 中的柯里化.md</li>\n<li>webpack 基础.md</li>\n<li>what-is-vanilla.js .md</li>\n<li>《了不起的 Node-js》摘记(1).md</li>\n<li>《了不起的 Node-js》摘记(2).md</li>\n<li>《人工智能狂潮》摘记.md</li>\n<li>上手 Promise.md</li>\n<li>初识动态规划.md</li>\n<li>前端校招面试会考察什么.md</li>\n<li>理解 Contentprovider.md</li>\n<li>阅读 Android 原生计算器源码.md</li>\n<li>阿里 2018 前端面试题解答.md</li>\n</ul>',frontmatter:{layout:"post",title:"之前写的博客",path:"/旧的文章/",categories:["oldBlog"],description:"之前的文章首部格式和现在有很大区别，没想到好的方法移过来，就在这放个链接吧。<!--more-->",date:"2017/10/01"}}}]}},pathContext:{}}}});
//# sourceMappingURL=path---index-b7ffc297d9c46282ea15.js.map